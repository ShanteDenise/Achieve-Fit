/*!
 * Module requirements.
 */

'use strict';

const MongooseError = require('../error');
const utils = require('../utils');

const SchemaType = require('../schematype');

const CastError = SchemaType.CastError;

/**
 * Date SchemaType constructor.
 *
 * @param {String***REMOVED*** key
 * @param {Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function SchemaDate(key, options) {
  SchemaType.call(this, key, options, 'Date');
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
SchemaDate.schemaName = 'Date';

/*!
 * Inherits from SchemaType.
 */
SchemaDate.prototype = Object.create(SchemaType.prototype);
SchemaDate.prototype.constructor = SchemaDate;

/**
 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
 *
 * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.
 * This index type is only compatible with Date types.
 *
 * ####Example:
 *
 *     // expire in 24 hours
 *     new Schema({ createdAt: { type: Date, expires: 60*60*24 ***REMOVED******REMOVED***);
 *
 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
 *
 * ####Example:
 *
 *     // expire in 24 hours
 *     new Schema({ createdAt: { type: Date, expires: '24h' ***REMOVED******REMOVED***);
 *
 *     // expire in 1.5 hours
 *     new Schema({ createdAt: { type: Date, expires: '1.5h' ***REMOVED******REMOVED***);
 *
 *     // expire in 7 days
 *     var schema = new Schema({ createdAt: Date ***REMOVED***);
 *     schema.path('createdAt').expires('7d');
 *
 * @param {Number|String***REMOVED*** when
 * @added 3.0.0
 * @return {SchemaType***REMOVED*** this
 * @api public
 */

SchemaDate.prototype.expires = function(when) {
  if (!this._index || this._index.constructor.name !== 'Object') {
    this._index = {***REMOVED***;
  ***REMOVED***

  this._index.expires = when;
  utils.expires(this._index);
  return this;
***REMOVED***;

/**
 * Check if the given value satisfies a required validator. To satisfy
 * a required validator, the given value must be an instance of `Date`.
 *
 * @param {Any***REMOVED*** value
 * @param {Document***REMOVED*** doc
 * @return {Boolean***REMOVED***
 * @api public
 */

SchemaDate.prototype.checkRequired = function(value) {
  return value instanceof Date;
***REMOVED***;

/**
 * Sets a minimum date validator.
 *
 * ####Example:
 *
 *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') ***REMOVED***)
 *     var M = db.model('M', s)
 *     var m = new M({ d: Date('1969-12-31') ***REMOVED***)
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.d = Date('2014-12-08');
 *       m.save() // success
 *     ***REMOVED***)
 *
 *     // custom error messages
 *     // We can also use the special {MIN***REMOVED*** token which will be replaced with the invalid value
 *     var min = [Date('1970-01-01'), 'The value of path `{PATH***REMOVED***` ({VALUE***REMOVED***) is beneath the limit ({MIN***REMOVED***).'];
 *     var schema = new Schema({ d: { type: Date, min: min ***REMOVED***)
 *     var M = mongoose.model('M', schema);
 *     var s= new M({ d: Date('1969-12-31') ***REMOVED***);
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
 *     ***REMOVED***)
 *
 * @param {Date***REMOVED*** value minimum date
 * @param {String***REMOVED*** [message] optional custom error message
 * @return {SchemaType***REMOVED*** this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaDate.prototype.min = function(value, message) {
  if (this.minValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.minValidator;
    ***REMOVED***, this);
  ***REMOVED***

  if (value) {
    let msg = message || MongooseError.messages.Date.min;
    msg = msg.replace(/{MIN***REMOVED***/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
    const _this = this;
    this.validators.push({
      validator: this.minValidator = function(val) {
        const min = (value === Date.now ? value() : _this.cast(value));
        return val === null || val.valueOf() >= min.valueOf();
      ***REMOVED***,
      message: msg,
      type: 'min',
      min: value
    ***REMOVED***);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Sets a maximum date validator.
 *
 * ####Example:
 *
 *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') ***REMOVED***)
 *     var M = db.model('M', s)
 *     var m = new M({ d: Date('2014-12-08') ***REMOVED***)
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.d = Date('2013-12-31');
 *       m.save() // success
 *     ***REMOVED***)
 *
 *     // custom error messages
 *     // We can also use the special {MAX***REMOVED*** token which will be replaced with the invalid value
 *     var max = [Date('2014-01-01'), 'The value of path `{PATH***REMOVED***` ({VALUE***REMOVED***) exceeds the limit ({MAX***REMOVED***).'];
 *     var schema = new Schema({ d: { type: Date, max: max ***REMOVED***)
 *     var M = mongoose.model('M', schema);
 *     var s= new M({ d: Date('2014-12-08') ***REMOVED***);
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
 *     ***REMOVED***)
 *
 * @param {Date***REMOVED*** maximum date
 * @param {String***REMOVED*** [message] optional custom error message
 * @return {SchemaType***REMOVED*** this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */

SchemaDate.prototype.max = function(value, message) {
  if (this.maxValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.maxValidator;
    ***REMOVED***, this);
  ***REMOVED***

  if (value) {
    let msg = message || MongooseError.messages.Date.max;
    msg = msg.replace(/{MAX***REMOVED***/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
    const _this = this;
    this.validators.push({
      validator: this.maxValidator = function(val) {
        const max = (value === Date.now ? value() : _this.cast(value));
        return val === null || val.valueOf() <= max.valueOf();
      ***REMOVED***,
      message: msg,
      type: 'max',
      max: value
    ***REMOVED***);
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Casts to date
 *
 * @param {Object***REMOVED*** value to cast
 * @api private
 */

SchemaDate.prototype.cast = function(value) {
  // If null or undefined
  if (value === null || value === void 0 || value === '') {
    return null;
  ***REMOVED***

  if (value instanceof Date) {
    if (isNaN(value.valueOf())) {
      throw new CastError('date', value, this.path);
    ***REMOVED***

    return value;
  ***REMOVED***

  let date;

  if (typeof value === 'boolean') {
    throw new CastError('date', value, this.path);
  ***REMOVED***

  if (value instanceof Number || typeof value === 'number') {
    date = new Date(value);
  ***REMOVED*** else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
    // string representation of milliseconds take this path
    date = new Date(Number(value));
  ***REMOVED*** else if (typeof value.valueOf === 'function') {
    // support for moment.js. This is also the path strings will take because
    // strings have a `valueOf()`
    date = new Date(value.valueOf());
  ***REMOVED***
    // fallback
    date = new Date(value);
  ***REMOVED***

  if (!isNaN(date.valueOf())) {
    return date;
  ***REMOVED***

  throw new CastError('date', value, this.path);
***REMOVED***;

/*!
 * Date Query casting.
 *
 * @api private
 */

function handleSingle(val) {
  return this.cast(val);
***REMOVED***

SchemaDate.prototype.$conditionalHandlers =
    utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    ***REMOVED***);


/**
 * Casts contents for queries.
 *
 * @param {String***REMOVED*** $conditional
 * @param {any***REMOVED*** [value]
 * @api private
 */

SchemaDate.prototype.castForQuery = function($conditional, val) {
  if (arguments.length !== 2) {
    return this._castForQuery($conditional);
  ***REMOVED***

  const handler = this.$conditionalHandlers[$conditional];

  if (!handler) {
    throw new Error('Can\'t use ' + $conditional + ' with Date.');
  ***REMOVED***

  return handler.call(this, val);
***REMOVED***;

/*!
 * Module exports.
 */

module.exports = SchemaDate;
