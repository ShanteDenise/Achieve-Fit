/*!
 * Module requirements.
 */

'use strict';

const castArraysOfNumbers = require('./helpers').castArraysOfNumbers;
const castToNumber = require('./helpers').castToNumber;

/*!
 * ignore
 */

exports.cast$geoIntersects = cast$geoIntersects;
exports.cast$near = cast$near;
exports.cast$within = cast$within;

function cast$near(val) {
  const SchemaArray = require('../array');

  if (Array.isArray(val)) {
    castArraysOfNumbers(val, this);
    return val;
  ***REMOVED***

  _castMinMaxDistance(this, val);

  if (val && val.$geometry) {
    return cast$geometry(val, this);
  ***REMOVED***

  return SchemaArray.prototype.castForQuery.call(this, val);
***REMOVED***

function cast$geometry(val, self) {
  switch (val.$geometry.type) {
    case 'Polygon':
    case 'LineString':
    case 'Point':
      castArraysOfNumbers(val.$geometry.coordinates, self);
      break;
    default:
      // ignore unknowns
      break;
  ***REMOVED***

  _castMinMaxDistance(self, val);

  return val;
***REMOVED***

function cast$within(val) {
  _castMinMaxDistance(this, val);

  if (val.$box || val.$polygon) {
    const type = val.$box ? '$box' : '$polygon';
    val[type].forEach(arr => {
      if (!Array.isArray(arr)) {
        const msg = 'Invalid $within $box argument. '
            + 'Expected an array, received ' + arr;
        throw new TypeError(msg);
      ***REMOVED***
      arr.forEach((v, i) => {
        arr[i] = castToNumber.call(this, v);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED*** else if (val.$center || val.$centerSphere) {
    const type = val.$center ? '$center' : '$centerSphere';
    val[type].forEach((item, i) => {
      if (Array.isArray(item)) {
        item.forEach((v, j) => {
          item[j] = castToNumber.call(this, v);
        ***REMOVED***);
      ***REMOVED***
        val[type][i] = castToNumber.call(this, item);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED*** else if (val.$geometry) {
    cast$geometry(val, this);
  ***REMOVED***

  return val;
***REMOVED***

function cast$geoIntersects(val) {
  const geo = val.$geometry;
  if (!geo) {
    return;
  ***REMOVED***

  cast$geometry(val, this);
  return val;
***REMOVED***

function _castMinMaxDistance(self, val) {
  if (val.$maxDistance) {
    val.$maxDistance = castToNumber.call(self, val.$maxDistance);
  ***REMOVED***
  if (val.$minDistance) {
    val.$minDistance = castToNumber.call(self, val.$minDistance);
  ***REMOVED***
***REMOVED***
