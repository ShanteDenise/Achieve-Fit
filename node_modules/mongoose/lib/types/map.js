'use strict';

const Mixed = require('../schema/mixed');
const util = require('util');

/*!
 * ignore
 */

class MongooseMap extends Map {
  constructor(v, path, doc, schemaType) {
    if (v != null && v.constructor.name === 'Object') {
      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
    ***REMOVED***
    super(v);

    this.$__parent = doc != null && doc.$__ != null ? doc : null;
    this.$__path = path;
    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;

    this.$__runDeferred();
  ***REMOVED***

  $init(key, value) {
    checkValidKey(key);

    super.set(key, value);

    if (value != null && value.$isSingleNested) {
      value.$basePath = this.$__path + '.' + key;
    ***REMOVED***
  ***REMOVED***

  set(key, value) {
    checkValidKey(key);

    // Weird, but because you can't assign to `this` before calling `super()`
    // you can't get access to `$__schemaType` to cast in the initial call to
    // `set()` from the `super()` constructor.

    if (this.$__schemaType == null) {
      this.$__deferred = this.$__deferred || [];
      this.$__deferred.push({ key: key, value: value ***REMOVED***);
      return;
    ***REMOVED***

    const fullPath = this.$__path + '.' + key;
    const populated = this.$__parent != null && this.$__parent.$__ ?
      this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) :
      null;

    if (populated != null) {
      if (value.$__ == null) {
        value = new populated.options.model(value);
      ***REMOVED***
      value.$__.wasPopulated = true;
    ***REMOVED***
      try {
        value = this.$__schemaType.
          applySetters(value, this.$__parent, false, this.get(key));
      ***REMOVED*** catch (error) {
        if (this.$__parent != null && this.$__parent.$__ != null) {
          this.$__parent.invalidate(fullPath, error);
          return;
        ***REMOVED***
        throw error;
      ***REMOVED***
    ***REMOVED***

    super.set(key, value);

    if (value != null && value.$isSingleNested) {
      value.$basePath = this.$__path + '.' + key;
    ***REMOVED***

    if (this.$__parent != null && this.$__parent.$__) {
      this.$__parent.markModified(this.$__path + '.' + key);
    ***REMOVED***
  ***REMOVED***

  toBSON() {
    return new Map(this);
  ***REMOVED***

  toObject() {
    return new Map(this);
  ***REMOVED***

  toJSON() {
    const ret = {***REMOVED***;
    const keys = this.keys();
    for (const key of keys) {
      ret[key] = this.get(key);
    ***REMOVED***
    return ret;
  ***REMOVED***

  inspect() {
    return new Map(this);
  ***REMOVED***

  $__runDeferred() {
    if (!this.$__deferred) {
      return;
    ***REMOVED***
    for (let i = 0; i < this.$__deferred.length; ++i) {
      this.set(this.$__deferred[i].key, this.$__deferred[i].value);
    ***REMOVED***
    this.$__deferred = null;
  ***REMOVED***
***REMOVED***

if (util.inspect.custom) {
  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
    enumerable: false,
    writable: false,
    configurable: false,
    value: MongooseMap.prototype.inspect
  ***REMOVED***);
***REMOVED***

Object.defineProperty(MongooseMap.prototype, '$__parent', {
  enumerable: false,
  writable: true,
  configurable: false
***REMOVED***);

Object.defineProperty(MongooseMap.prototype, '$__path', {
  enumerable: false,
  writable: true,
  configurable: false
***REMOVED***);

Object.defineProperty(MongooseMap.prototype, '$__schemaType', {
  enumerable: false,
  writable: true,
  configurable: false
***REMOVED***);

Object.defineProperty(MongooseMap.prototype, '$isMongooseMap', {
  enumerable: false,
  writable: false,
  configurable: false,
  value: true
***REMOVED***);

Object.defineProperty(MongooseMap.prototype, '$__deferredCalls', {
  enumerable: false,
  writable: false,
  configurable: false,
  value: true
***REMOVED***);

/*!
 * Since maps are stored as objects under the hood, keys must be strings
 * and can't contain any invalid characters
 */

function checkValidKey(key) {
  const keyType = typeof key;
  if (keyType !== 'string') {
    throw new TypeError(`Mongoose maps only support string keys, got ${keyType***REMOVED***`);
  ***REMOVED***
  if (key.startsWith('$')) {
    throw new Error(`Mongoose maps do not support keys that start with "$", got "${key***REMOVED***"`);
  ***REMOVED***
  if (key.includes('.')) {
    throw new Error(`Mongoose maps do not support keys that contain ".", got "${key***REMOVED***"`);
  ***REMOVED***
***REMOVED***

module.exports = MongooseMap;
