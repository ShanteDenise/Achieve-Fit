'use strict';

const modifiedPaths = require('./common').modifiedPaths;

/**
 * Applies defaults to update and findOneAndUpdate operations.
 *
 * @param {Object***REMOVED*** filter
 * @param {Schema***REMOVED*** schema
 * @param {Object***REMOVED*** castedDoc
 * @param {Object***REMOVED*** options
 * @method setDefaultsOnInsert
 * @api private
 */

module.exports = function(filter, schema, castedDoc, options) {
  const keys = Object.keys(castedDoc || {***REMOVED***);
  const updatedKeys = {***REMOVED***;
  const updatedValues = {***REMOVED***;
  const numKeys = keys.length;
  const modified = {***REMOVED***;

  let hasDollarUpdate = false;

  options = options || {***REMOVED***;

  if (!options.upsert || !options.setDefaultsOnInsert) {
    return castedDoc;
  ***REMOVED***

  for (let i = 0; i < numKeys; ++i) {
    if (keys[i].charAt(0) === '$') {
      modifiedPaths(castedDoc[keys[i]], '', modified);
      hasDollarUpdate = true;
    ***REMOVED***
  ***REMOVED***

  if (!hasDollarUpdate) {
    modifiedPaths(castedDoc, '', modified);
  ***REMOVED***

  const paths = Object.keys(filter);
  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    const path = paths[i];
    const condition = filter[path];
    if (condition && typeof condition === 'object') {
      const conditionKeys = Object.keys(condition);
      const numConditionKeys = conditionKeys.length;
      let hasDollarKey = false;
      for (let j = 0; j < numConditionKeys; ++j) {
        if (conditionKeys[j].charAt(0) === '$') {
          hasDollarKey = true;
          break;
        ***REMOVED***
      ***REMOVED***
      if (hasDollarKey) {
        continue;
      ***REMOVED***
    ***REMOVED***
    updatedKeys[path] = true;
    modified[path] = true;
  ***REMOVED***

  if (options && options.overwrite && !hasDollarUpdate) {
    // Defaults will be set later, since we're overwriting we'll cast
    // the whole update to a document
    return castedDoc;
  ***REMOVED***

  schema.eachPath(function(path, schemaType) {
    if (schemaType.$isSingleNested) {
      // Only handle nested schemas 1-level deep to avoid infinite
      // recursion re: https://github.com/mongodb-js/mongoose-autopopulate/issues/11
      schemaType.schema.eachPath(function(_path, _schemaType) {
        if (_path === '_id' && _schemaType.auto) {
          // Ignore _id if auto id so we don't create subdocs
          return;
        ***REMOVED***

        const def = _schemaType.getDefault(null, true);
        if (!isModified(modified, path + '.' + _path) &&
            typeof def !== 'undefined') {
          castedDoc = castedDoc || {***REMOVED***;
          castedDoc.$setOnInsert = castedDoc.$setOnInsert || {***REMOVED***;
          castedDoc.$setOnInsert[path + '.' + _path] = def;
          updatedValues[path + '.' + _path] = def;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
      const def = schemaType.getDefault(null, true);
      if (!isModified(modified, path) && typeof def !== 'undefined') {
        castedDoc = castedDoc || {***REMOVED***;
        castedDoc.$setOnInsert = castedDoc.$setOnInsert || {***REMOVED***;
        castedDoc.$setOnInsert[path] = def;
        updatedValues[path] = def;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return castedDoc;
***REMOVED***;

function isModified(modified, path) {
  if (modified[path]) {
    return true;
  ***REMOVED***
  const sp = path.split('.');
  let cur = sp[0];
  for (let i = 1; i < sp.length; ++i) {
    if (modified[cur]) {
      return true;
    ***REMOVED***
    cur += '.' + sp[i];
  ***REMOVED***
  return false;
***REMOVED***
