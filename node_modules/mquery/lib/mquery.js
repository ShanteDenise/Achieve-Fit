'use strict';

/**
 * Dependencies
 */

var slice = require('sliced');
var assert = require('assert');
var util = require('util');
var utils = require('./utils');
var debug = require('debug')('mquery');

/* global Map */

/**
 * Query constructor used for building queries.
 *
 * ####Example:
 *
 *     var query = new Query({ name: 'mquery' ***REMOVED***);
 *     query.setOptions({ collection: moduleCollection ***REMOVED***)
 *     query.where('age').gte(21).exec(callback);
 *
 * @param {Object***REMOVED*** [criteria]
 * @param {Object***REMOVED*** [options]
 * @api public
 */

function Query(criteria, options) {
  if (!(this instanceof Query))
    return new Query(criteria, options);

  var proto = this.constructor.prototype;

  this.op = proto.op || undefined;

  this.options = {***REMOVED***;
  this.setOptions(proto.options);

  this._conditions = proto._conditions
    ? utils.clone(proto._conditions)
    : {***REMOVED***;

  this._fields = proto._fields
    ? utils.clone(proto._fields)
    : undefined;

  this._update = proto._update
    ? utils.clone(proto._update)
    : undefined;

  this._path = proto._path || undefined;
  this._distinct = proto._distinct || undefined;
  this._collection = proto._collection || undefined;
  this._traceFunction = proto._traceFunction || undefined;

  if (options) {
    this.setOptions(options);
  ***REMOVED***

  if (criteria) {
    if (criteria.find && criteria.remove && criteria.update) {
      // quack quack!
      this.collection(criteria);
    ***REMOVED***
      this.find(criteria);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * This is a parameter that the user can set which determines if mquery
 * uses $within or $geoWithin for queries. It defaults to true which
 * means $geoWithin will be used. If using MongoDB < 2.4 you should
 * set this to false.
 *
 * @api public
 * @property use$geoWithin
 */

var $withinCmd = '$geoWithin';
Object.defineProperty(Query, 'use$geoWithin', {
  get: function( ) { return $withinCmd == '$geoWithin'; ***REMOVED***,
  set: function(v) {
    if (true === v) {
      // mongodb >= 2.4
      $withinCmd = '$geoWithin';
    ***REMOVED***
      $withinCmd = '$within';
    ***REMOVED***
  ***REMOVED***
***REMOVED***);

/**
 * Converts this query to a constructor function with all arguments and options retained.
 *
 * ####Example
 *
 *     // Create a query that will read documents with a "video" category from
 *     // `aCollection` on the primary node in the replica-set unless it is down,
 *     // in which case we'll read from a secondary node.
 *     var query = mquery({ category: 'video' ***REMOVED***)
 *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' ***REMOVED***);
 *
 *     // create a constructor based off these settings
 *     var Video = query.toConstructor();
 *
 *     // Video is now a subclass of mquery() and works the same way but with the
 *     // default query parameters and options set.
 *
 *     // run a query with the previous settings but filter for movies with names
 *     // that start with "Life".
 *     Video().where({ name: /^Life/ ***REMOVED***).exec(cb);
 *
 * @return {Query***REMOVED*** new Query
 * @api public
 */

Query.prototype.toConstructor = function toConstructor() {
  function CustomQuery(criteria, options) {
    if (!(this instanceof CustomQuery))
      return new CustomQuery(criteria, options);
    Query.call(this, criteria, options);
  ***REMOVED***

  utils.inherits(CustomQuery, Query);

  // set inherited defaults
  var p = CustomQuery.prototype;

  p.options = {***REMOVED***;
  p.setOptions(this.options);

  p.op = this.op;
  p._conditions = utils.clone(this._conditions);
  p._fields = utils.clone(this._fields);
  p._update = utils.clone(this._update);
  p._path = this._path;
  p._distinct = this._distinct;
  p._collection = this._collection;
  p._traceFunction = this._traceFunction;

  return CustomQuery;
***REMOVED***;

/**
 * Sets query options.
 *
 * ####Options:
 *
 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
 * - collection the collection to query against
 *
 * _* denotes a query helper method is also available_
 *
 * @param {Object***REMOVED*** options
 * @api public
 */

Query.prototype.setOptions = function(options) {
  if (!(options && utils.isObject(options)))
    return this;

  // set arbitrary options
  var methods = utils.keys(options),
      method;

  for (var i = 0; i < methods.length; ++i) {
    method = methods[i];

    // use methods if exist (safer option manipulation)
    if ('function' == typeof this[method]) {
      var args = utils.isArray(options[method])
        ? options[method]
        : [options[method]];
      this[method].apply(this, args);
    ***REMOVED***
      this.options[method] = options[method];
    ***REMOVED***
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Sets this Querys collection.
 *
 * @param {Collection***REMOVED*** coll
 * @return {Query***REMOVED*** this
 */

Query.prototype.collection = function collection(coll) {
  this._collection = new Query.Collection(coll);

  return this;
***REMOVED***;

/**
 * Adds a collation to this op (MongoDB 3.4 and up)
 *
 * ####Example
 *
 *     query.find().collation({ locale: "en_US", strength: 1 ***REMOVED***)
 *
 * @param {Object***REMOVED*** value
 * @return {Query***REMOVED*** this
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation
 * @api public
 */

Query.prototype.collation = function(value) {
  this.options.collation = value;
  return this;
***REMOVED***;

/**
 * Specifies a `$where` condition
 *
 * Use `$where` when you need to select documents using a JavaScript expression.
 *
 * ####Example
 *
 *     query.$where('this.comments.length > 10 || this.name.length > 5')
 *
 *     query.$where(function () {
 *       return this.comments.length > 10 || this.name.length > 5;
 *     ***REMOVED***)
 *
 * @param {String|Function***REMOVED*** js javascript string or function
 * @return {Query***REMOVED*** this
 * @memberOf Query
 * @method $where
 * @api public
 */

Query.prototype.$where = function(js) {
  this._conditions.$where = js;
  return this;
***REMOVED***;

/**
 * Specifies a `path` for use with chaining.
 *
 * ####Example
 *
 *     // instead of writing:
 *     User.find({age: {$gte: 21, $lte: 65***REMOVED******REMOVED***, callback);
 *
 *     // we can instead write:
 *     User.where('age').gte(21).lte(65);
 *
 *     // passing query conditions is permitted
 *     User.find().where({ name: 'vonderful' ***REMOVED***)
 *
 *     // chaining
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^vonderful/i)
 *     .where('friends').slice(10)
 *     .exec(callback)
 *
 * @param {String***REMOVED*** [path]
 * @param {Object***REMOVED*** [val]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.where = function() {
  if (!arguments.length) return this;
  if (!this.op) this.op = 'find';

  var type = typeof arguments[0];

  if ('string' == type) {
    this._path = arguments[0];

    if (2 === arguments.length) {
      this._conditions[this._path] = arguments[1];
    ***REMOVED***

    return this;
  ***REMOVED***

  if ('object' == type && !Array.isArray(arguments[0])) {
    return this.merge(arguments[0]);
  ***REMOVED***

  throw new TypeError('path must be a string or object');
***REMOVED***;

/**
 * Specifies the complementary comparison value for paths specified with `where()`
 *
 * ####Example
 *
 *     User.where('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param {Object***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.equals = function equals(val) {
  this._ensurePath('equals');
  var path = this._path;
  this._conditions[path] = val;
  return this;
***REMOVED***;

/**
 * Specifies the complementary comparison value for paths specified with `where()`
 * This is alias of `equals`
 *
 * ####Example
 *
 *     User.where('age').eq(49);
 *
 *     // is the same as
 *
 *     User.shere('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param {Object***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.eq = function eq(val) {
  this._ensurePath('eq');
  var path = this._path;
  this._conditions[path] = val;
  return this;
***REMOVED***;

/**
 * Specifies arguments for an `$or` condition.
 *
 * ####Example
 *
 *     query.or([{ color: 'red' ***REMOVED***, { status: 'emergency' ***REMOVED***])
 *
 * @param {Array***REMOVED*** array array of conditions
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.or = function or(array) {
  var or = this._conditions.$or || (this._conditions.$or = []);
  if (!utils.isArray(array)) array = [array];
  or.push.apply(or, array);
  return this;
***REMOVED***;

/**
 * Specifies arguments for a `$nor` condition.
 *
 * ####Example
 *
 *     query.nor([{ color: 'green' ***REMOVED***, { status: 'ok' ***REMOVED***])
 *
 * @param {Array***REMOVED*** array array of conditions
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.nor = function nor(array) {
  var nor = this._conditions.$nor || (this._conditions.$nor = []);
  if (!utils.isArray(array)) array = [array];
  nor.push.apply(nor, array);
  return this;
***REMOVED***;

/**
 * Specifies arguments for a `$and` condition.
 *
 * ####Example
 *
 *     query.and([{ color: 'green' ***REMOVED***, { status: 'ok' ***REMOVED***])
 *
 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
 * @param {Array***REMOVED*** array array of conditions
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.and = function and(array) {
  var and = this._conditions.$and || (this._conditions.$and = []);
  if (!Array.isArray(array)) array = [array];
  and.push.apply(and, array);
  return this;
***REMOVED***;

/**
 * Specifies a $gt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * ####Example
 *
 *     Thing.find().where('age').gt(21)
 *
 *     // or
 *     Thing.find().gt('age', 21)
 *
 * @method gt
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $gte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method gte
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $lt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lt
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $lte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lte
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $ne query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method ne
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $in query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method in
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $nin query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method nin
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies an $all query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method all
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $size query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method size
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $regex query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method regex
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {String|RegExp***REMOVED*** val
 * @api public
 */

/**
 * Specifies a $maxDistance query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method maxDistance
 * @memberOf Query
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @api public
 */

/*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */

'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function($conditional) {
  Query.prototype[$conditional] = function() {
    var path, val;

    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path = this._path;
    ***REMOVED***
      val = arguments[1];
      path = arguments[0];
    ***REMOVED***

    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?
      this._conditions[path] :
      (this._conditions[path] = {***REMOVED***);
    conds['$' + $conditional] = val;
    return this;
  ***REMOVED***;
***REMOVED***);

/**
 * Specifies a `$mod` condition
 *
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.mod = function() {
  var val, path;

  if (1 === arguments.length) {
    this._ensurePath('mod');
    val = arguments[0];
    path = this._path;
  ***REMOVED*** else if (2 === arguments.length && !utils.isArray(arguments[1])) {
    this._ensurePath('mod');
    val = slice(arguments);
    path = this._path;
  ***REMOVED*** else if (3 === arguments.length) {
    val = slice(arguments, 1);
    path = arguments[0];
  ***REMOVED***
    val = arguments[1];
    path = arguments[0];
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds.$mod = val;
  return this;
***REMOVED***;

/**
 * Specifies an `$exists` condition
 *
 * ####Example
 *
 *     // { name: { $exists: true ***REMOVED******REMOVED***
 *     Thing.where('name').exists()
 *     Thing.where('name').exists(true)
 *     Thing.find().exists('name')
 *
 *     // { name: { $exists: false ***REMOVED******REMOVED***
 *     Thing.where('name').exists(false);
 *     Thing.find().exists('name', false);
 *
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.exists = function() {
  var path, val;

  if (0 === arguments.length) {
    this._ensurePath('exists');
    path = this._path;
    val = true;
  ***REMOVED*** else if (1 === arguments.length) {
    if ('boolean' === typeof arguments[0]) {
      this._ensurePath('exists');
      path = this._path;
      val = arguments[0];
    ***REMOVED***
      path = arguments[0];
      val = true;
    ***REMOVED***
  ***REMOVED*** else if (2 === arguments.length) {
    path = arguments[0];
    val = arguments[1];
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds.$exists = val;
  return this;
***REMOVED***;

/**
 * Specifies an `$elemMatch` condition
 *
 * ####Example
 *
 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5***REMOVED******REMOVED***)
 *
 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5***REMOVED******REMOVED***)
 *
 *     query.elemMatch('comment', function (elem) {
 *       elem.where('author').equals('autobot');
 *       elem.where('votes').gte(5);
 *     ***REMOVED***)
 *
 *     query.where('comment').elemMatch(function (elem) {
 *       elem.where({ author: 'autobot' ***REMOVED***);
 *       elem.where('votes').gte(5);
 *     ***REMOVED***)
 *
 * @param {String|Object|Function***REMOVED*** path
 * @param {Object|Function***REMOVED*** criteria
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.elemMatch = function() {
  if (null == arguments[0])
    throw new TypeError('Invalid argument');

  var fn, path, criteria;

  if ('function' === typeof arguments[0]) {
    this._ensurePath('elemMatch');
    path = this._path;
    fn = arguments[0];
  ***REMOVED*** else if (utils.isObject(arguments[0])) {
    this._ensurePath('elemMatch');
    path = this._path;
    criteria = arguments[0];
  ***REMOVED*** else if ('function' === typeof arguments[1]) {
    path = arguments[0];
    fn = arguments[1];
  ***REMOVED*** else if (arguments[1] && utils.isObject(arguments[1])) {
    path = arguments[0];
    criteria = arguments[1];
  ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  if (fn) {
    criteria = new Query;
    fn(criteria);
    criteria = criteria._conditions;
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds.$elemMatch = criteria;
  return this;
***REMOVED***;

// Spatial queries

/**
 * Sugar for geo-spatial queries.
 *
 * ####Example
 *
 *     query.within().box()
 *     query.within().circle()
 *     query.within().geometry()
 *
 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true ***REMOVED***);
 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] ***REMOVED***);
 *     query.where('loc').within({ polygon: [[],[],[],[]] ***REMOVED***);
 *
 *     query.where('loc').within([], [], []) // polygon
 *     query.where('loc').within([], []) // box
 *     query.where('loc').within({ type: 'LineString', coordinates: [...] ***REMOVED***); // geometry
 *
 * ####NOTE:
 *
 * Must be used after `where()`.
 *
 * @memberOf Query
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.within = function within() {
  // opinionated, must be used after where
  this._ensurePath('within');
  this._geoComparison = $withinCmd;

  if (0 === arguments.length) {
    return this;
  ***REMOVED***

  if (2 === arguments.length) {
    return this.box.apply(this, arguments);
  ***REMOVED*** else if (2 < arguments.length) {
    return this.polygon.apply(this, arguments);
  ***REMOVED***

  var area = arguments[0];

  if (!area)
    throw new TypeError('Invalid argument');

  if (area.center)
    return this.circle(area);

  if (area.box)
    return this.box.apply(this, area.box);

  if (area.polygon)
    return this.polygon.apply(this, area.polygon);

  if (area.type && area.coordinates)
    return this.geometry(area);

  throw new TypeError('Invalid argument');
***REMOVED***;

/**
 * Specifies a $box condition
 *
 * ####Example
 *
 *     var lowerLeft = [40.73083, -73.99756]
 *     var upperRight= [40.741404,  -73.988135]
 *
 *     query.where('loc').within().box(lowerLeft, upperRight)
 *     query.box('loc', lowerLeft, upperRight )
 *
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see Query#within #query_Query-within
 * @param {String***REMOVED*** path
 * @param {Object***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.box = function() {
  var path, box;

  if (3 === arguments.length) {
    // box('loc', [], [])
    path = arguments[0];
    box = [arguments[1], arguments[2]];
  ***REMOVED*** else if (2 === arguments.length) {
    // box([], [])
    this._ensurePath('box');
    path = this._path;
    box = [arguments[0], arguments[1]];
  ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds[this._geoComparison || $withinCmd] = { '$box': box ***REMOVED***;
  return this;
***REMOVED***;

/**
 * Specifies a $polygon condition
 *
 * ####Example
 *
 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
 *     query.polygon('loc', [10,20], [13, 25], [7,15])
 *
 * @param {String|Array***REMOVED*** [path]
 * @param {Array|Object***REMOVED*** [val]
 * @return {Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.polygon = function() {
  var val, path;

  if ('string' == typeof arguments[0]) {
    // polygon('loc', [],[],[])
    path = arguments[0];
    val = slice(arguments, 1);
  ***REMOVED***
    // polygon([],[],[])
    this._ensurePath('polygon');
    path = this._path;
    val = slice(arguments);
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds[this._geoComparison || $withinCmd] = { '$polygon': val ***REMOVED***;
  return this;
***REMOVED***;

/**
 * Specifies a $center or $centerSphere condition.
 *
 * ####Example
 *
 *     var area = { center: [50, 50], radius: 10, unique: true ***REMOVED***
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 *     // for spherical calculations
 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true ***REMOVED***
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 * @param {String***REMOVED*** [path]
 * @param {Object***REMOVED*** area
 * @return {Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.circle = function() {
  var path, val;

  if (1 === arguments.length) {
    this._ensurePath('circle');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) {
    path = arguments[0];
    val = arguments[1];
  ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  if (!('radius' in val && val.center))
    throw new Error('center and radius are required');

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);

  var type = val.spherical
    ? '$centerSphere'
    : '$center';

  var wKey = this._geoComparison || $withinCmd;
  conds[wKey] = {***REMOVED***;
  conds[wKey][type] = [val.center, val.radius];

  if ('unique' in val)
    conds[wKey].$uniqueDocs = !!val.unique;

  return this;
***REMOVED***;

/**
 * Specifies a `$near` or `$nearSphere` condition
 *
 * These operators return documents sorted by distance.
 *
 * ####Example
 *
 *     query.where('loc').near({ center: [10, 10] ***REMOVED***);
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 ***REMOVED***);
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true ***REMOVED***);
 *     query.near('loc', { center: [10, 10], maxDistance: 5 ***REMOVED***);
 *     query.near({ center: { type: 'Point', coordinates: [..] ***REMOVED******REMOVED***)
 *     query.near().geometry({ type: 'Point', coordinates: [..] ***REMOVED***)
 *
 * @param {String***REMOVED*** [path]
 * @param {Object***REMOVED*** val
 * @return {Query***REMOVED*** this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */

Query.prototype.near = function near() {
  var path, val;

  this._geoComparison = '$near';

  if (0 === arguments.length) {
    return this;
  ***REMOVED*** else if (1 === arguments.length) {
    this._ensurePath('near');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) {
    path = arguments[0];
    val = arguments[1];
  ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  if (!val.center) {
    throw new Error('center is required');
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);

  var type = val.spherical
    ? '$nearSphere'
    : '$near';

  // center could be a GeoJSON object or an Array
  if (Array.isArray(val.center)) {
    conds[type] = val.center;

    var radius = 'maxDistance' in val
      ? val.maxDistance
      : null;

    if (null != radius) {
      conds.$maxDistance = radius;
    ***REMOVED***
    if (null != val.minDistance) {
      conds.$minDistance = val.minDistance;
    ***REMOVED***
  ***REMOVED***
    // GeoJSON?
    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {
      throw new Error(util.format('Invalid GeoJSON specified for %s', type));
    ***REMOVED***
    conds[type] = { $geometry : val.center ***REMOVED***;

    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
    if ('maxDistance' in val) {
      conds[type]['$maxDistance'] = val.maxDistance;
    ***REMOVED***
    if ('minDistance' in val) {
      conds[type]['$minDistance'] = val.minDistance;
    ***REMOVED***
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Declares an intersects query for `geometry()`.
 *
 * ####Example
 *
 *     query.where('path').intersects().geometry({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     ***REMOVED***)
 *
 *     query.where('path').intersects({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     ***REMOVED***)
 *
 * @param {Object***REMOVED*** [arg]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.intersects = function intersects() {
  // opinionated, must be used after where
  this._ensurePath('intersects');

  this._geoComparison = '$geoIntersects';

  if (0 === arguments.length) {
    return this;
  ***REMOVED***

  var area = arguments[0];

  if (null != area && area.type && area.coordinates)
    return this.geometry(area);

  throw new TypeError('Invalid argument');
***REMOVED***;

/**
 * Specifies a `$geometry` condition
 *
 * ####Example
 *
 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA ***REMOVED***)
 *
 *     // or
 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB ***REMOVED***)
 *
 *     // or
 *     var polyC = [ 0, 0 ]
 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC ***REMOVED***)
 *
 *     // or
 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC ***REMOVED***)
 *
 * ####NOTE:
 *
 * `geometry()` **must** come after either `intersects()` or `within()`.
 *
 * The `object` argument must contain `type` and `coordinates` properties.
 * - type {String***REMOVED***
 * - coordinates {Array***REMOVED***
 *
 * The most recent path passed to `where()` is used.
 *
 * @param {Object***REMOVED*** object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
 * @return {Query***REMOVED*** this
 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
 * @api public
 */

Query.prototype.geometry = function geometry() {
  if (!('$within' == this._geoComparison ||
        '$geoWithin' == this._geoComparison ||
        '$near' == this._geoComparison ||
        '$geoIntersects' == this._geoComparison)) {
    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');
  ***REMOVED***

  var val, path;

  if (1 === arguments.length) {
    this._ensurePath('geometry');
    path = this._path;
    val = arguments[0];
  ***REMOVED***
    throw new TypeError('Invalid argument');
  ***REMOVED***

  if (!(val.type && Array.isArray(val.coordinates))) {
    throw new TypeError('Invalid argument');
  ***REMOVED***

  var conds = this._conditions[path] || (this._conditions[path] = {***REMOVED***);
  conds[this._geoComparison] = { $geometry: val ***REMOVED***;

  return this;
***REMOVED***;

// end spatial

/**
 * Specifies which document fields to include or exclude
 *
 * ####String syntax
 *
 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
 *
 * ####Example
 *
 *     // include a and b, exclude c
 *     query.select('a b -c');
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     query.select({a: 1, b: 1, c: 0***REMOVED***);
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Object|String***REMOVED*** arg
 * @return {Query***REMOVED*** this
 * @see SchemaType
 * @api public
 */

Query.prototype.select = function select() {
  var arg = arguments[0];
  if (!arg) return this;

  if (arguments.length !== 1) {
    throw new Error('Invalid select: select only takes 1 argument');
  ***REMOVED***

  this._validate('select');

  var fields = this._fields || (this._fields = {***REMOVED***);
  var type = typeof arg;
  var i, len;

  if (('string' == type || utils.isArgumentsObject(arg)) &&
    'number' == typeof arg.length || Array.isArray(arg)) {
    if ('string' == type)
      arg = arg.split(/\s+/);

    for (i = 0, len = arg.length; i < len; ++i) {
      var field = arg[i];
      if (!field) continue;
      var include = '-' == field[0] ? 0 : 1;
      if (include === 0) field = field.substring(1);
      fields[field] = include;
    ***REMOVED***

    return this;
  ***REMOVED***

  if (utils.isObject(arg)) {
    var keys = utils.keys(arg);
    for (i = 0; i < keys.length; ++i) {
      fields[keys[i]] = arg[keys[i]];
    ***REMOVED***
    return this;
  ***REMOVED***

  throw new TypeError('Invalid select() argument. Must be string or object.');
***REMOVED***;

/**
 * Specifies a $slice condition for a `path`
 *
 * ####Example
 *
 *     query.slice('comments', 5)
 *     query.slice('comments', -5)
 *     query.slice('comments', [10, 5])
 *     query.where('comments').slice(5)
 *     query.where('comments').slice([-10, 5])
 *
 * @param {String***REMOVED*** [path]
 * @param {Number***REMOVED*** val number/range of elements to slice
 * @return {Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
 * @api public
 */

Query.prototype.slice = function() {
  if (0 === arguments.length)
    return this;

  this._validate('slice');

  var path, val;

  if (1 === arguments.length) {
    var arg = arguments[0];
    if (typeof arg === 'object' && !Array.isArray(arg)) {
      var keys = Object.keys(arg);
      var numKeys = keys.length;
      for (var i = 0; i < numKeys; ++i) {
        this.slice(keys[i], arg[keys[i]]);
      ***REMOVED***
      return this;
    ***REMOVED***
    this._ensurePath('slice');
    path = this._path;
    val = arguments[0];
  ***REMOVED*** else if (2 === arguments.length) {
    if ('number' === typeof arguments[0]) {
      this._ensurePath('slice');
      path = this._path;
      val = slice(arguments);
    ***REMOVED***
      path = arguments[0];
      val = arguments[1];
    ***REMOVED***
  ***REMOVED*** else if (3 === arguments.length) {
    path = arguments[0];
    val = slice(arguments, 1);
  ***REMOVED***

  var myFields = this._fields || (this._fields = {***REMOVED***);
  myFields[path] = { '$slice': val ***REMOVED***;
  return this;
***REMOVED***;

/**
 * Sets the sort order
 *
 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * ####Example
 *
 *     // these are equivalent
 *     query.sort({ field: 'asc', test: -1 ***REMOVED***);
 *     query.sort('field -test');
 *     query.sort([['field', 1], ['test', -1]]);
 *
 * ####Note
 *
 *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).
 *  - Cannot be used with `distinct()`
 *
 * @param {Object|String|Array***REMOVED*** arg
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.sort = function(arg) {
  if (!arg) return this;
  var i, len, field;

  this._validate('sort');

  var type = typeof arg;

  // .sort([['field', 1], ['test', -1]])
  if (Array.isArray(arg)) {
    len = arg.length;
    for (i = 0; i < arg.length; ++i) {
      if (!Array.isArray(arg[i])) {
        throw new Error('Invalid sort() argument, must be array of arrays');
      ***REMOVED***
      _pushArr(this.options, arg[i][0], arg[i][1]);
    ***REMOVED***
    return this;
  ***REMOVED***

  // .sort('field -test')
  if (1 === arguments.length && 'string' == type) {
    arg = arg.split(/\s+/);
    len = arg.length;
    for (i = 0; i < len; ++i) {
      field = arg[i];
      if (!field) continue;
      var ascend = '-' == field[0] ? -1 : 1;
      if (ascend === -1) field = field.substring(1);
      push(this.options, field, ascend);
    ***REMOVED***

    return this;
  ***REMOVED***

  // .sort({ field: 1, test: -1 ***REMOVED***)
  if (utils.isObject(arg)) {
    var keys = utils.keys(arg);
    for (i = 0; i < keys.length; ++i) {
      field = keys[i];
      push(this.options, field, arg[field]);
    ***REMOVED***

    return this;
  ***REMOVED***

  if (typeof Map !== 'undefined' && arg instanceof Map) {
    _pushMap(this.options, arg);
    return this;
  ***REMOVED***
  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');
***REMOVED***;

/*!
 * @ignore
 */

var _validSortValue = {
  '1': 1,
  '-1': -1,
  'asc': 1,
  'ascending': 1,
  'desc': -1,
  'descending': -1
***REMOVED***;

function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw new TypeError('Can\'t mix sort syntaxes. Use either array or object:' +
      '\n- `.sort([[\'field\', 1], [\'test\', -1]])`' +
      '\n- `.sort({ field: 1, test: -1 ***REMOVED***)`');
  ***REMOVED***

  var s;
  if (value && value.$meta) {
    s = opts.sort || (opts.sort = {***REMOVED***);
    s[field] = { $meta : value.$meta ***REMOVED***;
    return;
  ***REMOVED***

  s = opts.sort || (opts.sort = {***REMOVED***);
  var val = String(value || 1).toLowerCase();
  val = _validSortValue[val];
  if (!val) throw new TypeError('Invalid sort value: { ' + field + ': ' + value + ' ***REMOVED***');

  s[field] = val;
***REMOVED***

function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw new TypeError('Can\'t mix sort syntaxes. Use either array or object:' +
      '\n- `.sort([[\'field\', 1], [\'test\', -1]])`' +
      '\n- `.sort({ field: 1, test: -1 ***REMOVED***)`');
  ***REMOVED***

  var val = String(value || 1).toLowerCase();
  val = _validSortValue[val];
  if (!val) throw new TypeError('Invalid sort value: [ ' + field + ', ' + value + ' ]');

  opts.sort.push([field, val]);
***REMOVED***

function _pushMap(opts, map) {
  opts.sort = opts.sort || new Map();
  if (!(opts.sort instanceof Map)) {
    throw new TypeError('Can\'t mix sort syntaxes. Use either array or ' +
      'object or map consistently');
  ***REMOVED***
  map.forEach(function(value, key) {
    var val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val) throw new TypeError('Invalid sort value: < ' + key + ': ' + value + ' >');

    opts.sort.set(key, val);
  ***REMOVED***);
***REMOVED***



/**
 * Specifies the limit option.
 *
 * ####Example
 *
 *     query.limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method limit
 * @memberOf Query
 * @param {Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the skip option.
 *
 * ####Example
 *
 *     query.skip(100).limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method skip
 * @memberOf Query
 * @param {Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the maxScan option.
 *
 * ####Example
 *
 *     query.maxScan(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method maxScan
 * @memberOf Query
 * @param {Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
 * @api public
 */
/**
 * Specifies the batchSize option.
 *
 * ####Example
 *
 *     query.batchSize(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method batchSize
 * @memberOf Query
 * @param {Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
 * @api public
 */
/**
 * Specifies the `comment` option.
 *
 * ####Example
 *
 *     query.comment('login query')
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method comment
 * @memberOf Query
 * @param {Number***REMOVED*** val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
 * @api public
 */

/*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */

['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function(method) {
  Query.prototype[method] = function(v) {
    this._validate(method);
    this.options[method] = v;
    return this;
  ***REMOVED***;
***REMOVED***);

/**
 * Specifies the maxTimeMS option.
 *
 * ####Example
 *
 *     query.maxTime(100)
 *     query.maxTimeMS(100)
 *
 * @method maxTime
 * @memberOf Query
 * @param {Number***REMOVED*** ms
 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
 * @api public
 */

Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
  this._validate('maxTime');
  this.options.maxTimeMS = ms;
  return this;
***REMOVED***;

/**
 * Specifies this query as a `snapshot` query.
 *
 * ####Example
 *
 *     mquery().snapshot() // true
 *     mquery().snapshot(true)
 *     mquery().snapshot(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.snapshot = function() {
  this._validate('snapshot');

  this.options.snapshot = arguments.length
    ? !!arguments[0]
    : true;

  return this;
***REMOVED***;

/**
 * Sets query hints.
 *
 * ####Example
 *
 *     query.hint({ indexA: 1, indexB: -1***REMOVED***);
 *     query.hint('indexA_1_indexB_1');
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Object|string***REMOVED*** val a hint object or the index name
 * @return {Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
 * @api public
 */

Query.prototype.hint = function() {
  if (0 === arguments.length) return this;

  this._validate('hint');

  var arg = arguments[0];
  if (utils.isObject(arg)) {
    var hint = this.options.hint || (this.options.hint = {***REMOVED***);

    // must keep object keys in order so don't use Object.keys()
    for (var k in arg) {
      hint[k] = arg[k];
    ***REMOVED***

    return this;
  ***REMOVED***
  if (typeof arg === 'string') {
    this.options.hint = arg;
    return this;
  ***REMOVED***

  throw new TypeError('Invalid hint. ' + arg);
***REMOVED***;

/**
 * Requests acknowledgement that this operation has been persisted to MongoDB's
 * on-disk journal.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the `j` value if it is specified in writeConcern options
 *
 * ####Example:
 *
 *     mquery().w(2).j(true).wtimeout(2000);
 *
 * @method j
 * @memberOf Query
 * @instance
 * @param {boolean***REMOVED*** val
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.j = function j(val) {
  this.options.j = val;
  return this;
***REMOVED***;

/**
 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
 *
 * ####Example:
 *
 *     query.slaveOk() // true
 *     query.slaveOk(true)
 *     query.slaveOk(false)
 *
 * @deprecated use read() preferences instead if on mongodb >= 2.2
 * @param {Boolean***REMOVED*** v defaults to true
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see read()
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.slaveOk = function(v) {
  this.options.slaveOk = arguments.length ? !!v : true;
  return this;
***REMOVED***;

/**
 * Sets the readPreference option for the query.
 *
 * ####Example:
 *
 *     new Query().read('primary')
 *     new Query().read('p')  // same as primary
 *
 *     new Query().read('primaryPreferred')
 *     new Query().read('pp') // same as primaryPreferred
 *
 *     new Query().read('secondary')
 *     new Query().read('s')  // same as secondary
 *
 *     new Query().read('secondaryPreferred')
 *     new Query().read('sp') // same as secondaryPreferred
 *
 *     new Query().read('nearest')
 *     new Query().read('n')  // same as nearest
 *
 *     // you can also use mongodb.ReadPreference class to also specify tags
 *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 ***REMOVED***,{ dc:'ma', s: 2 ***REMOVED***]))
 *
 *     new Query().setReadPreference('primary') // alias of .read()
 *
 * ####Preferences:
 *
 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
 *     secondary            Read from secondary if available, otherwise error.
 *     primaryPreferred     Read from primary if available, otherwise a secondary.
 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
 *
 * Aliases
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
 *
 * @param {String|ReadPreference***REMOVED*** pref one of the listed preference options or their aliases
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
    console.error('Deprecation warning: \'tags\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.');
    Query.prototype.read.deprecationWarningIssued = true;
  ***REMOVED***
  this.options.readPreference = utils.readPref(pref);
  return this;
***REMOVED***;

/**
 * Sets the readConcern option for the query.
 *
 * ####Example:
 *
 *     new Query().readConcern('local')
 *     new Query().readConcern('l')  // same as local
 *
 *     new Query().readConcern('available')
 *     new Query().readConcern('a')  // same as available
 *
 *     new Query().readConcern('majority')
 *     new Query().readConcern('m')  // same as majority
 *
 *     new Query().readConcern('linearizable')
 *     new Query().readConcern('lz') // same as linearizable
 *
 *     new Query().readConcern('snapshot')
 *     new Query().readConcern('s')  // same as snapshot
 *
 *     new Query().r('s') // r is alias of readConcern
 *
 *
 * ####Read Concern Level:
 *
 *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.
 *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.
 *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.


 *
 *
 * Aliases
 *
 *     l   local
 *     a   available
 *     m   majority
 *     lz  linearizable
 *     s   snapshot
 *
 * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).
 *
 * @param {String***REMOVED*** level one of the listed read concern level or their aliases
 * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.readConcern = Query.prototype.r = function(level) {
  this.options.readConcern = utils.readConcern(level);
  return this;
***REMOVED***;

/**
 * Sets tailable option.
 *
 * ####Example
 *
 *     query.tailable() <== true
 *     query.tailable(true)
 *     query.tailable(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Boolean***REMOVED*** v defaults to true
 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
 * @api public
 */

Query.prototype.tailable = function() {
  this._validate('tailable');

  this.options.tailable = arguments.length
    ? !!arguments[0]
    : true;

  return this;
***REMOVED***;

/**
 * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,
 * that must acknowledge this write before this write is considered successful.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the `w` value if it is specified in writeConcern options
 *
 * ####Example:
 *
 * mquery().writeConcern(0)
 * mquery().writeConcern(1)
 * mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 ***REMOVED***)
 * mquery().writeConcern('majority')
 * mquery().writeConcern('m') // same as majority
 * mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' ***REMOVED***) instead
 * mquery().w(1) // w is alias of writeConcern
 *
 * @method writeConcern
 * @memberOf Query
 * @instance
 * @param {String|number|object***REMOVED*** concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
  if ('object' === typeof concern) {
    if ('undefined' !== typeof concern.j) this.options.j = concern.j;
    if ('undefined' !== typeof concern.w) this.options.w = concern.w;
    if ('undefined' !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;
  ***REMOVED***
    this.options.w = 'm' === concern ? 'majority' : concern;
  ***REMOVED***
  return this;
***REMOVED***;

/**
 * Specifies a time limit, in milliseconds, for the write concern.
 * If `ms > 1`, it is maximum amount of time to wait for this write
 * to propagate through the replica set before this operation fails.
 * The default is `0`, which means no timeout.
 *
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to `wtimeout` value if it is specified in writeConcern
 *
 * ####Example:
 *
 *     mquery().w(2).j(true).wtimeout(2000)
 *
 * @method wtimeout
 * @memberOf Query
 * @instance
 * @param {number***REMOVED*** ms number of milliseconds to wait
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
  this.options.wtimeout = ms;
  return this;
***REMOVED***;

/**
 * Merges another Query or conditions object into this one.
 *
 * When a Query is passed, conditions, field selection and options are merged.
 *
 * @param {Query|Object***REMOVED*** source
 * @return {Query***REMOVED*** this
 */

Query.prototype.merge = function(source) {
  if (!source)
    return this;

  if (!Query.canMerge(source))
    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');

  if (source instanceof Query) {
    // if source has a feature, apply it to ourselves

    if (source._conditions) {
      utils.merge(this._conditions, source._conditions);
    ***REMOVED***

    if (source._fields) {
      this._fields || (this._fields = {***REMOVED***);
      utils.merge(this._fields, source._fields);
    ***REMOVED***

    if (source.options) {
      this.options || (this.options = {***REMOVED***);
      utils.merge(this.options, source.options);
    ***REMOVED***

    if (source._update) {
      this._update || (this._update = {***REMOVED***);
      utils.mergeClone(this._update, source._update);
    ***REMOVED***

    if (source._distinct) {
      this._distinct = source._distinct;
    ***REMOVED***

    return this;
  ***REMOVED***

  // plain object
  utils.merge(this._conditions, source);

  return this;
***REMOVED***;

/**
 * Finds documents.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.find()
 *     query.find(callback)
 *     query.find({ name: 'Burning Lights' ***REMOVED***, callback)
 *
 * @param {Object***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.find = function(criteria, callback) {
  this.op = 'find';

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var conds = this._conditions;
  var options = this._optionsForExec();

  if (this.$useProjection) {
    options.projection = this._fieldsForExec();
  ***REMOVED***
    options.fields = this._fieldsForExec();
  ***REMOVED***

  debug('find', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('find', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.find(conds, options, utils.tick(callback));
  return this;
***REMOVED***;

/**
 * Returns the query cursor
 *
 * ####Examples
 *
 *     query.find().cursor();
 *     query.cursor({ name: 'Burning Lights' ***REMOVED***);
 *
 * @param {Object***REMOVED*** [criteria] mongodb selector
 * @return {Object***REMOVED*** cursor
 * @api public
 */

Query.prototype.cursor = function cursor(criteria) {
  if (this.op) {
    if (this.op !== 'find') {
      throw new TypeError('.cursor only support .find method');
    ***REMOVED***
  ***REMOVED***
    this.find(criteria);
  ***REMOVED***

  var conds = this._conditions;
  var options = this._optionsForExec();

  if (this.$useProjection) {
    options.projection = this._fieldsForExec();
  ***REMOVED***
    options.fields = this._fieldsForExec();
  ***REMOVED***

  debug('findCursor', this._collection.collectionName, conds, options);
  return this._collection.findCursor(conds, options);
***REMOVED***;

/**
 * Executes the query as a findOne() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.findOne().where('name', /^Burning/);
 *
 *     query.findOne({ name: /^Burning/ ***REMOVED***)
 *
 *     query.findOne({ name: /^Burning/ ***REMOVED***, callback); // executes
 *
 *     query.findOne(function (err, doc) {
 *       if (err) return handleError(err);
 *       if (doc) {
 *         // doc may be null if no document matched
 *
 *       ***REMOVED***
 *     ***REMOVED***);
 *
 * @param {Object|Query***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.findOne = function(criteria, callback) {
  this.op = 'findOne';

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var conds = this._conditions;
  var options = this._optionsForExec();

  if (this.$useProjection) {
    options.projection = this._fieldsForExec();
  ***REMOVED***
    options.fields = this._fieldsForExec();
  ***REMOVED***

  debug('findOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('findOne', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.findOne(conds, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Exectues the query as a count() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.count().where('color', 'black').exec(callback);
 *
 *     query.count({ color: 'black' ***REMOVED***).count(callback)
 *
 *     query.count({ color: 'black' ***REMOVED***, callback)
 *
 *     query.where('color', 'black').count(function (err, count) {
 *       if (err) return handleError(err);
 *       console.log('there are %d kittens', count);
 *     ***REMOVED***)
 *
 * @param {Object***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
 * @api public
 */

Query.prototype.count = function(criteria, callback) {
  this.op = 'count';
  this._validate();

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED***

  if (!callback) return this;

  var conds = this._conditions,
      options = this._optionsForExec();

  debug('count', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('count', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.count(conds, options, utils.tick(callback));
  return this;
***REMOVED***;

/**
 * Declares or executes a distinct() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     distinct(criteria, field, fn)
 *     distinct(criteria, field)
 *     distinct(field, fn)
 *     distinct(field)
 *     distinct(fn)
 *     distinct()
 *
 * @param {Object|Query***REMOVED*** [criteria]
 * @param {String***REMOVED*** [field]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
 * @api public
 */

Query.prototype.distinct = function(criteria, field, callback) {
  this.op = 'distinct';
  this._validate();

  if (!callback) {
    switch (typeof field) {
      case 'function':
        callback = field;
        if ('string' == typeof criteria) {
          field = criteria;
          criteria = undefined;
        ***REMOVED***
        break;
      case 'undefined':
      case 'string':
        break;
      default:
        throw new TypeError('Invalid `field` argument. Must be string or function');
    ***REMOVED***

    switch (typeof criteria) {
      case 'function':
        callback = criteria;
        criteria = field = undefined;
        break;
      case 'string':
        field = criteria;
        criteria = undefined;
        break;
    ***REMOVED***
  ***REMOVED***

  if ('string' == typeof field) {
    this._distinct = field;
  ***REMOVED***

  if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED***

  if (!callback) {
    return this;
  ***REMOVED***

  if (!this._distinct) {
    throw new Error('No value for `distinct` has been declared');
  ***REMOVED***

  var conds = this._conditions,
      options = this._optionsForExec();

  debug('distinct', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('distinct', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Declare and/or execute this query as an update() operation. By default,
 * `update()` only modifies the _first_ document that matches `criteria`.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     mquery({ _id: id ***REMOVED***).update({ title: 'words' ***REMOVED***, ...)
 *
 * becomes
 *
 *     collection.update({ _id: id ***REMOVED***, { $set: { title: 'words' ***REMOVED******REMOVED***, ...)
 *
 * ####Note
 *
 * Passing an empty object `{***REMOVED***` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
 *
 *     var q = mquery(collection).where({ _id: id ***REMOVED***);
 *     q.update({ $set: { name: 'bob' ***REMOVED******REMOVED***).update(); // not executed
 *
 *     var q = mquery(collection).where({ _id: id ***REMOVED***);
 *     q.update({ $set: { name: 'bob' ***REMOVED******REMOVED***).exec(); // executed as unsafe
 *
 *     // keys that are not $atomic ops become $set.
 *     // this executes the same command as the previous example.
 *     q.update({ name: 'bob' ***REMOVED***).where({ _id: id ***REMOVED***).exec();
 *
 *     var q = mquery(collection).update(); // not executed
 *
 *     // overwriting with empty docs
 *     var q.where({ _id: id ***REMOVED***).setOptions({ overwrite: true ***REMOVED***)
 *     q.update({ ***REMOVED***, callback); // executes
 *
 *     // multi update with overwrite to empty doc
 *     var q = mquery(collection).where({ _id: id ***REMOVED***);
 *     q.setOptions({ multi: true, overwrite: true ***REMOVED***)
 *     q.update({ ***REMOVED***);
 *     q.update(callback); // executed
 *
 *     // multi updates
 *     mquery()
 *       .collection(coll)
 *       .update({ name: /^match/ ***REMOVED***, { $set: { arr: [] ***REMOVED******REMOVED***, { multi: true ***REMOVED***, callback)
 *     // more multi updates
 *     mquery({ ***REMOVED***)
 *       .collection(coll)
 *       .setOptions({ multi: true ***REMOVED***)
 *       .update({ $set: { arr: [] ***REMOVED******REMOVED***, callback)
 *
 *     // single update by default
 *     mquery({ email: 'address@example.com' ***REMOVED***)
 *      .collection(coll)
 *      .update({ $inc: { counter: 1 ***REMOVED******REMOVED***, callback)
 *
 *     // summary
 *     update(criteria, doc, opts, cb) // executes
 *     update(criteria, doc, opts)
 *     update(criteria, doc, cb) // executes
 *     update(criteria, doc)
 *     update(doc, cb) // executes
 *     update(doc)
 *     update(cb) // executes
 *     update(true) // executes (unsafe write)
 *     update()
 *
 * @param {Object***REMOVED*** [criteria]
 * @param {Object***REMOVED*** [doc] the update command
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.update = function update(criteria, doc, options, callback) {
  var force;

  switch (arguments.length) {
    case 3:
      if ('function' == typeof options) {
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) {
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'update', criteria, doc, options, force, callback);
***REMOVED***;

/**
 * Declare and/or execute this query as an `updateMany()` operation. Identical
 * to `update()` except `updateMany()` will update _all_ documents that match
 * `criteria`, rather than just the first one.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update every document whose `title` contains 'test'
 *     mquery().updateMany({ title: /test/ ***REMOVED***, { year: 2017 ***REMOVED***)
 *
 * @param {Object***REMOVED*** [criteria]
 * @param {Object***REMOVED*** [doc] the update command
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.updateMany = function updateMany(criteria, doc, options, callback) {
  var force;

  switch (arguments.length) {
    case 3:
      if ('function' == typeof options) {
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) {
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'updateMany', criteria, doc, options, force, callback);
***REMOVED***;

/**
 * Declare and/or execute this query as an `updateOne()` operation. Identical
 * to `update()` except `updateOne()` will _always_ update just one document,
 * regardless of the `multi` option.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update the first document whose `title` contains 'test'
 *     mquery().updateMany({ title: /test/ ***REMOVED***, { year: 2017 ***REMOVED***)
 *
 * @param {Object***REMOVED*** [criteria]
 * @param {Object***REMOVED*** [doc] the update command
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.updateOne = function updateOne(criteria, doc, options, callback) {
  var force;

  switch (arguments.length) {
    case 3:
      if ('function' == typeof options) {
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) {
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  return _update(this, 'updateOne', criteria, doc, options, force, callback);
***REMOVED***;

/**
 * Declare and/or execute this query as an `replaceOne()` operation. Similar
 * to `updateOne()`, except `replaceOne()` is not allowed to use atomic
 * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always
 * replace the existing doc.
 *
 * ####Example
 *
 *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 ***REMOVED***`
 *     mquery().replaceOne({ _id: 1 ***REMOVED***, { year: 2017 ***REMOVED***)
 *
 * @param {Object***REMOVED*** [criteria]
 * @param {Object***REMOVED*** [doc] the update command
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {
  var force;

  switch (arguments.length) {
    case 3:
      if ('function' == typeof options) {
        callback = options;
        options = undefined;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      break;
    case 1:
      switch (typeof criteria) {
        case 'function':
          callback = criteria;
          criteria = options = doc = undefined;
          break;
        case 'boolean':
          // execution with no callback (unsafe write)
          force = criteria;
          criteria = undefined;
          break;
        default:
          doc = criteria;
          criteria = options = undefined;
          break;
      ***REMOVED***
  ***REMOVED***

  this.setOptions({ overwrite: true ***REMOVED***);
  return _update(this, 'replaceOne', criteria, doc, options, force, callback);
***REMOVED***;


/*!
 * Internal helper for update, updateMany, updateOne
 */

function _update(query, op, criteria, doc, options, force, callback) {
  query.op = op;

  if (Query.canMerge(criteria)) {
    query.merge(criteria);
  ***REMOVED***

  if (doc) {
    query._mergeUpdate(doc);
  ***REMOVED***

  if (utils.isObject(options)) {
    // { overwrite: true ***REMOVED***
    query.setOptions(options);
  ***REMOVED***

  // we are done if we don't have callback and they are
  // not forcing an unsafe write.
  if (!(force || callback)) {
    return query;
  ***REMOVED***

  if (!query._update ||
      !query.options.overwrite && 0 === utils.keys(query._update).length) {
    callback && utils.soon(callback.bind(null, null, 0));
    return query;
  ***REMOVED***

  options = query._optionsForExec();
  if (!callback) options.safe = false;

  criteria = query._conditions;
  doc = query._updateForExec();

  debug('update', query._collection.collectionName, criteria, doc, options);
  callback = query._wrapCallback(op, callback, {
    conditions: criteria,
    doc: doc,
    options: options
  ***REMOVED***);

  query._collection[op](criteria, doc, options, utils.tick(callback));

  return query;
***REMOVED***

/**
 * Declare and/or execute this query as a remove() operation.
 *
 * ####Example
 *
 *     mquery(collection).remove({ artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
 *
 *     // not executed
 *     var query = mquery(collection).remove({ name: 'Anne Murray' ***REMOVED***)
 *
 *     // executed
 *     mquery(collection).remove({ name: 'Anne Murray' ***REMOVED***, callback)
 *     mquery(collection).remove({ name: 'Anne Murray' ***REMOVED***).remove(callback)
 *
 *     // executed without a callback (unsafe write)
 *     query.exec()
 *
 *     // summary
 *     query.remove(conds, fn); // executes
 *     query.remove(conds)
 *     query.remove(fn) // executes
 *     query.remove()
 *
 * @param {Object|Query***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.remove = function(criteria, callback) {
  this.op = 'remove';
  var force;

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) {
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec();
  if (!callback) options.safe = false;

  var conds = this._conditions;

  debug('remove', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('remove', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.remove(conds, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Declare and/or execute this query as a `deleteOne()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes at
 * most one document.
 *
 * ####Example
 *
 *     mquery(collection).deleteOne({ artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * @param {Object|Query***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.deleteOne = function(criteria, callback) {
  this.op = 'deleteOne';
  var force;

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) {
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec();
  if (!callback) options.safe = false;
  delete options.justOne;

  var conds = this._conditions;

  debug('deleteOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('deleteOne', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.deleteOne(conds, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Declare and/or execute this query as a `deleteMany()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes
 * _every_ document that matches `criteria`.
 *
 * ####Example
 *
 *     mquery(collection).deleteMany({ artist: 'Anne Murray' ***REMOVED***, callback)
 *
 * @param {Object|Query***REMOVED*** [criteria] mongodb selector
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.deleteMany = function(criteria, callback) {
  this.op = 'deleteMany';
  var force;

  if ('function' === typeof criteria) {
    callback = criteria;
    criteria = undefined;
  ***REMOVED*** else if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED*** else if (true === criteria) {
    force = criteria;
    criteria = undefined;
  ***REMOVED***

  if (!(force || callback))
    return this;

  var options = this._optionsForExec();
  if (!callback) options.safe = false;
  delete options.justOne;

  var conds = this._conditions;

  debug('deleteOne', this._collection.collectionName, conds, options);
  callback = this._wrapCallback('deleteOne', callback, {
    conditions: conds,
    options: options
  ***REMOVED***);

  this._collection.deleteMany(conds, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
 *
 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `new`: bool - true to return the modified document rather than the original. defaults to true
 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
 *     query.findOneAndUpdate(conditions, update, callback) // executes
 *     query.findOneAndUpdate(conditions, update)           // returns Query
 *     query.findOneAndUpdate(update, callback)             // returns Query
 *     query.findOneAndUpdate(update)                       // returns Query
 *     query.findOneAndUpdate(callback)                     // executes
 *     query.findOneAndUpdate()                             // returns Query
 *
 * @param {Object|Query***REMOVED*** [query]
 * @param {Object***REMOVED*** [doc]
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @return {Query***REMOVED*** this
 * @api public
 */

Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
  this.op = 'findOneAndUpdate';
  this._validate();

  switch (arguments.length) {
    case 3:
      if ('function' == typeof options) {
        callback = options;
        options = {***REMOVED***;
      ***REMOVED***
      break;
    case 2:
      if ('function' == typeof doc) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      ***REMOVED***
      options = undefined;
      break;
    case 1:
      if ('function' == typeof criteria) {
        callback = criteria;
        criteria = options = doc = undefined;
      ***REMOVED***
        doc = criteria;
        criteria = options = undefined;
      ***REMOVED***
  ***REMOVED***

  if (Query.canMerge(criteria)) {
    this.merge(criteria);
  ***REMOVED***

  // apply doc
  if (doc) {
    this._mergeUpdate(doc);
  ***REMOVED***

  options && this.setOptions(options);

  if (!callback) return this;
  return this._findAndModify('update', callback);
***REMOVED***;

/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
 *
 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     A.where().findOneAndRemove(conditions, options, callback) // executes
 *     A.where().findOneAndRemove(conditions, options)  // return Query
 *     A.where().findOneAndRemove(conditions, callback) // executes
 *     A.where().findOneAndRemove(conditions) // returns Query
 *     A.where().findOneAndRemove(callback)   // executes
 *     A.where().findOneAndRemove()           // returns Query
 *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()
 *
 * @param {Object***REMOVED*** [conditions]
 * @param {Object***REMOVED*** [options]
 * @param {Function***REMOVED*** [callback]
 * @return {Query***REMOVED*** this
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */

Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {
  this.op = 'findOneAndRemove';
  this._validate();

  if ('function' == typeof options) {
    callback = options;
    options = undefined;
  ***REMOVED*** else if ('function' == typeof conditions) {
    callback = conditions;
    conditions = undefined;
  ***REMOVED***

  // apply conditions
  if (Query.canMerge(conditions)) {
    this.merge(conditions);
  ***REMOVED***

  // apply options
  options && this.setOptions(options);

  if (!callback) return this;

  return this._findAndModify('remove', callback);
***REMOVED***;

/**
 * _findAndModify
 *
 * @param {String***REMOVED*** type - either "remove" or "update"
 * @param {Function***REMOVED*** callback
 * @api private
 */

Query.prototype._findAndModify = function(type, callback) {
  assert.equal('function', typeof callback);

  var options = this._optionsForExec();
  var fields;
  var doc;

  if ('remove' == type) {
    options.remove = true;
  ***REMOVED***
    if (!('new' in options)) options.new = true;
    if (!('upsert' in options)) options.upsert = false;

    doc = this._updateForExec();
    if (!doc) {
      if (options.upsert) {
        // still need to do the upsert to empty doc
        doc = { $set: {***REMOVED*** ***REMOVED***;
      ***REMOVED***
        return this.findOne(callback);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  fields = this._fieldsForExec();
  if (fields != null) {
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    ***REMOVED***
      options.fields = this._fieldsForExec();
    ***REMOVED***
  ***REMOVED***

  var conds = this._conditions;

  debug('findAndModify', this._collection.collectionName, conds, doc, options);
  callback = this._wrapCallback('findAndModify', callback, {
    conditions: conds,
    doc: doc,
    options: options
  ***REMOVED***);

  this._collection.findAndModify(conds, doc, options, utils.tick(callback));

  return this;
***REMOVED***;

/**
 * Wrap callback to add tracing
 *
 * @param {Function***REMOVED*** callback
 * @param {Object***REMOVED*** [queryInfo]
 * @api private
 */
Query.prototype._wrapCallback = function(method, callback, queryInfo) {
  var traceFunction = this._traceFunction || Query.traceFunction;

  if (traceFunction) {
    queryInfo.collectionName = this._collection.collectionName;

    var traceCallback = traceFunction &&
      traceFunction.call(null, method, queryInfo, this);

    var startTime = new Date().getTime();

    return function wrapperCallback(err, result) {
      if (traceCallback) {
        var millis = new Date().getTime() - startTime;
        traceCallback.call(null, err, result, millis);
      ***REMOVED***

      if (callback) {
        callback.apply(null, arguments);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  return callback;
***REMOVED***;

/**
 * Add trace function that gets called when the query is executed.
 * The function will be called with (method, queryInfo, query) and
 * should return a callback function which will be called
 * with (err, result, millis) when the query is complete.
 *
 * queryInfo is an object containing: {
 *   collectionName: <name of the collection>,
 *   conditions: <query criteria>,
 *   options: <comment, fields, readPreference, etc>,
 *   doc: [document to update, if applicable]
 * ***REMOVED***
 *
 * NOTE: Does not trace stream queries.
 *
 * @param {Function***REMOVED*** traceFunction
 * @return {Query***REMOVED*** this
 * @api public
 */
Query.prototype.setTraceFunction = function(traceFunction) {
  this._traceFunction = traceFunction;
  return this;
***REMOVED***;

/**
 * Executes the query
 *
 * ####Examples
 *
 *     query.exec();
 *     query.exec(callback);
 *     query.exec('update');
 *     query.exec('find', callback);
 *
 * @param {String|Function***REMOVED*** [operation]
 * @param {Function***REMOVED*** [callback]
 * @api public
 */

Query.prototype.exec = function exec(op, callback) {
  switch (typeof op) {
    case 'function':
      callback = op;
      op = null;
      break;
    case 'string':
      this.op = op;
      break;
  ***REMOVED***

  assert.ok(this.op, 'Missing query type: (find, update, etc)');

  if ('update' == this.op || 'remove' == this.op) {
    callback || (callback = true);
  ***REMOVED***

  var _this = this;

  if ('function' == typeof callback) {
    this[this.op](callback);
  ***REMOVED***
    return new Query.Promise(function(success, error) {
      _this[_this.op](function(err, val) {
        if (err) error(err);
        else success(val);
        success = error = null;
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Returns a thunk which when called runs this.exec()
 *
 * The thunk receives a callback function which will be
 * passed to `this.exec()`
 *
 * @return {Function***REMOVED***
 * @api public
 */

Query.prototype.thunk = function() {
  var _this = this;
  return function(cb) {
    _this.exec(cb);
  ***REMOVED***;
***REMOVED***;

/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 *
 * @param {Function***REMOVED*** [resolve]
 * @param {Function***REMOVED*** [reject]
 * @return {Promise***REMOVED***
 * @api public
 */

Query.prototype.then = function(resolve, reject) {
  var _this = this;
  var promise = new Query.Promise(function(success, error) {
    _this.exec(function(err, val) {
      if (err) error(err);
      else success(val);
      success = error = null;
    ***REMOVED***);
  ***REMOVED***);
  return promise.then(resolve, reject);
***REMOVED***;

/**
 * Returns a stream for the given find query.
 *
 * @throws Error if operation is not a find
 * @returns {Stream***REMOVED*** Node 0.8 style
 */

Query.prototype.stream = function(streamOptions) {
  if ('find' != this.op)
    throw new Error('stream() is only available for find');

  var conds = this._conditions;

  var options = this._optionsForExec();
  if (this.$useProjection) {
    options.projection = this._fieldsForExec();
  ***REMOVED***
    options.fields = this._fieldsForExec();
  ***REMOVED***

  debug('stream', this._collection.collectionName, conds, options, streamOptions);

  return this._collection.findStream(conds, options, streamOptions);
***REMOVED***;

/**
 * Determines if field selection has been made.
 *
 * @return {Boolean***REMOVED***
 * @api public
 */

Query.prototype.selected = function selected() {
  return !!(this._fields && Object.keys(this._fields).length > 0);
***REMOVED***;

/**
 * Determines if inclusive field selection has been made.
 *
 *     query.selectedInclusively() // false
 *     query.select('name')
 *     query.selectedInclusively() // true
 *     query.selectedExlusively() // false
 *
 * @returns {Boolean***REMOVED***
 */

Query.prototype.selectedInclusively = function selectedInclusively() {
  if (!this._fields) return false;

  var keys = Object.keys(this._fields);
  if (0 === keys.length) return false;

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    if (0 === this._fields[key]) return false;
    if (this._fields[key] &&
        typeof this._fields[key] === 'object' &&
        this._fields[key].$meta) {
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/**
 * Determines if exclusive field selection has been made.
 *
 *     query.selectedExlusively() // false
 *     query.select('-name')
 *     query.selectedExlusively() // true
 *     query.selectedInclusively() // false
 *
 * @returns {Boolean***REMOVED***
 */

Query.prototype.selectedExclusively = function selectedExclusively() {
  if (!this._fields) return false;

  var keys = Object.keys(this._fields);
  if (0 === keys.length) return false;

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    if (0 === this._fields[key]) return true;
  ***REMOVED***

  return false;
***REMOVED***;

/**
 * Merges `doc` with the current update object.
 *
 * @param {Object***REMOVED*** doc
 */

Query.prototype._mergeUpdate = function(doc) {
  if (!this._update) this._update = {***REMOVED***;
  if (doc instanceof Query) {
    if (doc._update) {
      utils.mergeClone(this._update, doc._update);
    ***REMOVED***
  ***REMOVED***
    utils.mergeClone(this._update, doc);
  ***REMOVED***
***REMOVED***;

/**
 * Returns default options.
 *
 * @return {Object***REMOVED***
 * @api private
 */

Query.prototype._optionsForExec = function() {
  var options = utils.clone(this.options);
  return options;
***REMOVED***;

/**
 * Returns fields selection for this query.
 *
 * @return {Object***REMOVED***
 * @api private
 */

Query.prototype._fieldsForExec = function() {
  return utils.clone(this._fields);
***REMOVED***;

/**
 * Return an update document with corrected $set operations.
 *
 * @api private
 */

Query.prototype._updateForExec = function() {
  var update = utils.clone(this._update),
      ops = utils.keys(update),
      i = ops.length,
      ret = {***REMOVED***;

  while (i--) {
    var op = ops[i];

    if (this.options.overwrite) {
      ret[op] = update[op];
      continue;
    ***REMOVED***

    if ('$' !== op[0]) {
      // fix up $set sugar
      if (!ret.$set) {
        if (update.$set) {
          ret.$set = update.$set;
        ***REMOVED***
          ret.$set = {***REMOVED***;
        ***REMOVED***
      ***REMOVED***
      ret.$set[op] = update[op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    ***REMOVED*** else if ('$set' === op) {
      if (!ret.$set) {
        ret[op] = update[op];
      ***REMOVED***
    ***REMOVED***
      ret[op] = update[op];
    ***REMOVED***
  ***REMOVED***

  this._compiledUpdate = ret;
  return ret;
***REMOVED***;

/**
 * Make sure _path is set.
 *
 * @parmam {String***REMOVED*** method
 */

Query.prototype._ensurePath = function(method) {
  if (!this._path) {
    var msg = method + '() must be used after where() '
                     + 'when called with these arguments';
    throw new Error(msg);
  ***REMOVED***
***REMOVED***;

/*!
 * Permissions
 */

Query.permissions = require('./permissions');

Query._isPermitted = function(a, b) {
  var denied = Query.permissions[b];
  if (!denied) return true;
  return true !== denied[a];
***REMOVED***;

Query.prototype._validate = function(action) {
  var fail;
  var validator;

  if (undefined === action) {

    validator = Query.permissions[this.op];
    if ('function' != typeof validator) return true;

    fail = validator(this);

  ***REMOVED*** else if (!Query._isPermitted(action, this.op)) {
    fail = action;
  ***REMOVED***

  if (fail) {
    throw new Error(fail + ' cannot be used with ' + this.op);
  ***REMOVED***
***REMOVED***;

/**
 * Determines if `conds` can be merged using `mquery().merge()`
 *
 * @param {Object***REMOVED*** conds
 * @return {Boolean***REMOVED***
 */

Query.canMerge = function(conds) {
  return conds instanceof Query || utils.isObject(conds);
***REMOVED***;

/**
 * Set a trace function that will get called whenever a
 * query is executed.
 *
 * See `setTraceFunction()` for details.
 *
 * @param {Object***REMOVED*** conds
 * @return {Boolean***REMOVED***
 */
Query.setGlobalTraceFunction = function(traceFunction) {
  Query.traceFunction = traceFunction;
***REMOVED***;

/*!
 * Exports.
 */

Query.utils = utils;
Query.env = require('./env');
Query.Collection = require('./collection');
Query.BaseCollection = require('./collection/collection');
Query.Promise = require('bluebird');
module.exports = exports = Query;

// TODO
// test utils
