"use strict";
module.exports = function(Promise, INTERNAL, debug) {
var util = require("./util");
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  {
    this.handle = handle;
***REMOVED***

HandleWrapper.prototype._resultCancelled = function() {
    clearTimeout(this.handle);
***REMOVED***;

var afterValue = function(value) { return delay(+this).thenReturn(value); ***REMOVED***;
var delay = Promise.delay = function (ms, value) {
    var ret;
    var handle;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise) {
            ret._setOnCancel(value);
        ***REMOVED***
    ***REMOVED***
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() { ret._fulfill(); ***REMOVED***, +ms);
        if (debug.cancellation()) {
            ret._setOnCancel(new HandleWrapper(handle));
        ***REMOVED***
        ret._captureStackTrace();
    ***REMOVED***
    ret._setAsyncGuaranteed();
    return ret;
***REMOVED***;

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
***REMOVED***;

var afterTimeout = function (promise, message, parent) {
    var err;
    if (typeof message !== "string") {
        if (message instanceof Error) {
            err = message;
        ***REMOVED***
            err = new TimeoutError("operation timed out");
        ***REMOVED***
    ***REMOVED***
        err = new TimeoutError(message);
    ***REMOVED***
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) {
        parent.cancel();
    ***REMOVED***
***REMOVED***;

function successClear(value) {
    clearTimeout(this.handle);
    return value;
***REMOVED***

function failureClear(reason) {
    clearTimeout(this.handle);
    throw reason;
***REMOVED***

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
            afterTimeout(ret, message, parent);
        ***REMOVED***
    ***REMOVED***, ms));

    if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    ***REMOVED***
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    ***REMOVED***

    return ret;
***REMOVED***;

***REMOVED***;
