'use strict';

const deprecate = require('util').deprecate;
const deprecateOptions = require('./utils').deprecateOptions;
const checkCollectionName = require('./utils').checkCollectionName;
const ObjectID = require('mongodb-core').BSON.ObjectID;
const AggregationCursor = require('./aggregation_cursor');
const MongoError = require('mongodb-core').MongoError;
const toError = require('./utils').toError;
const normalizeHintField = require('./utils').normalizeHintField;
const handleCallback = require('./utils').handleCallback;
const decorateWithCollation = require('./utils').decorateWithCollation;
const decorateWithReadConcern = require('./utils').decorateWithReadConcern;
const formattedOrderClause = require('./utils').formattedOrderClause;
const ReadPreference = require('mongodb-core').ReadPreference;
const CommandCursor = require('./command_cursor');
const unordered = require('./bulk/unordered');
const ordered = require('./bulk/ordered');
const ChangeStream = require('./change_stream');
const executeOperation = require('./utils').executeOperation;
const applyWriteConcern = require('./utils').applyWriteConcern;
const resolveReadPreference = require('./utils').resolveReadPreference;

// Operations
const bulkWrite = require('./operations/collection_ops').bulkWrite;
const checkForAtomicOperators = require('./operations/collection_ops').checkForAtomicOperators;
const count = require('./operations/collection_ops').count;
const countDocuments = require('./operations/collection_ops').countDocuments;
const createIndex = require('./operations/collection_ops').createIndex;
const createIndexes = require('./operations/collection_ops').createIndexes;
const deleteMany = require('./operations/collection_ops').deleteMany;
const deleteOne = require('./operations/collection_ops').deleteOne;
const distinct = require('./operations/collection_ops').distinct;
const dropIndex = require('./operations/collection_ops').dropIndex;
const dropIndexes = require('./operations/collection_ops').dropIndexes;
const ensureIndex = require('./operations/collection_ops').ensureIndex;
const findAndModify = require('./operations/collection_ops').findAndModify;
const findAndRemove = require('./operations/collection_ops').findAndRemove;
const findOne = require('./operations/collection_ops').findOne;
const findOneAndDelete = require('./operations/collection_ops').findOneAndDelete;
const findOneAndReplace = require('./operations/collection_ops').findOneAndReplace;
const findOneAndUpdate = require('./operations/collection_ops').findOneAndUpdate;
const geoHaystackSearch = require('./operations/collection_ops').geoHaystackSearch;
const group = require('./operations/collection_ops').group;
const indexes = require('./operations/collection_ops').indexes;
const indexExists = require('./operations/collection_ops').indexExists;
const indexInformation = require('./operations/collection_ops').indexInformation;
const insertOne = require('./operations/collection_ops').insertOne;
const isCapped = require('./operations/collection_ops').isCapped;
const mapReduce = require('./operations/collection_ops').mapReduce;
const optionsOp = require('./operations/collection_ops').optionsOp;
const parallelCollectionScan = require('./operations/collection_ops').parallelCollectionScan;
const prepareDocs = require('./operations/collection_ops').prepareDocs;
const reIndex = require('./operations/collection_ops').reIndex;
const removeDocuments = require('./operations/collection_ops').removeDocuments;
const rename = require('./operations/collection_ops').rename;
const replaceOne = require('./operations/collection_ops').replaceOne;
const save = require('./operations/collection_ops').save;
const stats = require('./operations/collection_ops').stats;
const updateDocuments = require('./operations/collection_ops').updateDocuments;
const updateMany = require('./operations/collection_ops').updateMany;
const updateOne = require('./operations/collection_ops').updateOne;

/**
 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @example
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Create a collection we want to drop later
 *   const col = client.db(dbName).collection('createIndexExample1');
 *   // Show that duplicate records got dropped
 *   col.find({***REMOVED***).toArray(function(err, items) {
 *     test.equal(null, err);
 *     test.equal(4, items.length);
 *     client.close();
 *   ***REMOVED***);
 * ***REMOVED***);
 */

const mergeKeys = ['ignoreUndefined'];

/**
 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property {string***REMOVED*** collectionName Get the collection name.
 * @property {string***REMOVED*** namespace Get the full collection namespace.
 * @property {object***REMOVED*** writeConcern The current write concern values.
 * @property {object***REMOVED*** readConcern The current read concern values.
 * @property {object***REMOVED*** hint Get current index hint for collection.
 * @return {Collection***REMOVED*** a Collection instance.
 */
function Collection(db, topology, dbName, name, pkFactory, options) {
  checkCollectionName(name);

  // Unpack variables
  const internalHint = null;
  const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  const serializeFunctions =
    options == null || options.serializeFunctions == null
      ? db.s.options.serializeFunctions
      : options.serializeFunctions;
  const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
  const promoteLongs =
    options == null || options.promoteLongs == null
      ? db.s.options.promoteLongs
      : options.promoteLongs;
  const promoteValues =
    options == null || options.promoteValues == null
      ? db.s.options.promoteValues
      : options.promoteValues;
  const promoteBuffers =
    options == null || options.promoteBuffers == null
      ? db.s.options.promoteBuffers
      : options.promoteBuffers;
  let readPreference = null;
  const collectionHint = null;
  const namespace = `${dbName***REMOVED***.${name***REMOVED***`;

  // Get the promiseLibrary
  const promiseLibrary = options.promiseLibrary || Promise;

  // Assign the right collection level readPreference
  if (options && options.readPreference) {
    readPreference = options.readPreference;
  ***REMOVED*** else if (db.options.readPreference) {
    readPreference = db.options.readPreference;
  ***REMOVED***

  // Set custom primary key factory if provided
  pkFactory = pkFactory == null ? ObjectID : pkFactory;

  // Internal state
  this.s = {
    // Set custom primary key factory if provided
    pkFactory: pkFactory,
    // Db
    db: db,
    // Topology
    topology: topology,
    // dbName
    dbName: dbName,
    // Options
    options: options,
    // Namespace
    namespace: namespace,
    // Read preference
    readPreference: readPreference,
    // SlaveOK
    slaveOk: slaveOk,
    // Serialize functions
    serializeFunctions: serializeFunctions,
    // Raw
    raw: raw,
    // promoteLongs
    promoteLongs: promoteLongs,
    // promoteValues
    promoteValues: promoteValues,
    // promoteBuffers
    promoteBuffers: promoteBuffers,
    // internalHint
    internalHint: internalHint,
    // collectionHint
    collectionHint: collectionHint,
    // Name
    name: name,
    // Promise library
    promiseLibrary: promiseLibrary,
    // Read Concern
    readConcern: options.readConcern,
    // Write Concern
    writeConcern: options.writeConcern
  ***REMOVED***;
***REMOVED***

Object.defineProperty(Collection.prototype, 'dbName', {
  enumerable: true,
  get: function() {
    return this.s.dbName;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'collectionName', {
  enumerable: true,
  get: function() {
    return this.s.name;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'namespace', {
  enumerable: true,
  get: function() {
    return this.s.namespace;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'readConcern', {
  enumerable: true,
  get: function() {
    return this.s.readConcern || { level: 'local' ***REMOVED***;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'writeConcern', {
  enumerable: true,
  get: function() {
    let ops = {***REMOVED***;
    if (this.s.writeConcern) {
      return this.s.writeConcern;
    ***REMOVED***

    if (this.s.options.w != null) ops.w = this.s.options.w;
    if (this.s.options.j != null) ops.j = this.s.options.j;
    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  ***REMOVED***
***REMOVED***);

/**
 * @ignore
 */
Object.defineProperty(Collection.prototype, 'hint', {
  enumerable: true,
  get: function() {
    return this.s.collectionHint;
  ***REMOVED***,
  set: function(v) {
    this.s.collectionHint = normalizeHintField(v);
  ***REMOVED***
***REMOVED***);

const DEPRECATED_FIND_OPTIONS = ['maxScan', 'fields', 'snapshot'];

/**
 * Creates a cursor for a query that can be used to iterate over results from MongoDB
 * @method
 * @param {object***REMOVED*** [query={***REMOVED***] The cursor query object.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {number***REMOVED*** [options.limit=0] Sets the limit of documents returned in the query.
 * @param {(array|object)***REMOVED*** [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param {object***REMOVED*** [options.projection] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1***REMOVED***
 * @param {object***REMOVED*** [options.fields] **Deprecated** Use `options.projection` instead
 * @param {number***REMOVED*** [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param {Object***REMOVED*** [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1***REMOVED***
 * @param {boolean***REMOVED*** [options.explain=false] Explain the query instead of returning the data.
 * @param {boolean***REMOVED*** [options.snapshot=false] DEPRECATED: Snapshot query.
 * @param {boolean***REMOVED*** [options.timeout=false] Specify if the cursor can timeout.
 * @param {boolean***REMOVED*** [options.tailable=false] Specify if the cursor is tailable.
 * @param {number***REMOVED*** [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {boolean***REMOVED*** [options.returnKey=false] Only return the index key.
 * @param {number***REMOVED*** [options.maxScan] DEPRECATED: Limit the number of items to scan.
 * @param {number***REMOVED*** [options.min] Set index bounds.
 * @param {number***REMOVED*** [options.max] Set index bounds.
 * @param {boolean***REMOVED*** [options.showDiskLoc=false] Show disk location of results.
 * @param {string***REMOVED*** [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param {boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean***REMOVED*** [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @throws {MongoError***REMOVED***
 * @return {Cursor***REMOVED***
 */
Collection.prototype.find = deprecateOptions(
  {
    name: 'collection.find',
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  ***REMOVED***,
  function(query, options, callback) {
    if (typeof callback === 'object') {
      // TODO(MAJOR): throw in the future
      console.warn('Third parameter to `find()` must be a callback or undefined');
    ***REMOVED***

    let selector = query;
    // figuring out arguments
    if (typeof callback !== 'function') {
      if (typeof options === 'function') {
        callback = options;
        options = undefined;
      ***REMOVED*** else if (options == null) {
        callback = typeof selector === 'function' ? selector : undefined;
        selector = typeof selector === 'object' ? selector : undefined;
      ***REMOVED***
    ***REMOVED***

    // Ensure selector is not null
    selector = selector == null ? {***REMOVED*** : selector;
    // Validate correctness off the selector
    const object = selector;
    if (Buffer.isBuffer(object)) {
      const object_size = object[0] | (object[1] << 8) | (object[2] << 16) | (object[3] << 24);
      if (object_size !== object.length) {
        const error = new Error(
          'query selector raw message size does not match message header size [' +
            object.length +
            '] != [' +
            object_size +
            ']'
        );
        error.name = 'MongoError';
        throw error;
      ***REMOVED***
    ***REMOVED***

    // Check special case where we are using an objectId
    if (selector != null && selector._bsontype === 'ObjectID') {
      selector = { _id: selector ***REMOVED***;
    ***REMOVED***

    if (!options) options = {***REMOVED***;

    let projection = options.projection || options.fields;

    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
      projection = projection.length
        ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          ***REMOVED***, {***REMOVED***)
        : { _id: 1 ***REMOVED***;
    ***REMOVED***

    // Make a shallow copy of options
    let newOptions = Object.assign({***REMOVED***, options);

    // Make a shallow copy of the collection options
    for (let key in this.s.options) {
      if (mergeKeys.indexOf(key) !== -1) {
        newOptions[key] = this.s.options[key];
      ***REMOVED***
    ***REMOVED***

    // Unpack options
    newOptions.skip = options.skip ? options.skip : 0;
    newOptions.limit = options.limit ? options.limit : 0;
    newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;
    newOptions.hint =
      options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
    newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout;
    // // If we have overridden slaveOk otherwise use the default db setting
    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;

    // Add read preference if needed
    newOptions.readPreference = resolveReadPreference(newOptions, {
      db: this.s.db,
      collection: this
    ***REMOVED***);

    // Set slave ok to true if read preference different from primary
    if (
      newOptions.readPreference != null &&
      (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')
    ) {
      newOptions.slaveOk = true;
    ***REMOVED***

    // Ensure the query is an object
    if (selector != null && typeof selector !== 'object') {
      throw MongoError.create({ message: 'query selector must be an object', driver: true ***REMOVED***);
    ***REMOVED***

    // Build the find command
    const findCommand = {
      find: this.s.namespace,
      limit: newOptions.limit,
      skip: newOptions.skip,
      query: selector
    ***REMOVED***;

    // Ensure we use the right await data option
    if (typeof newOptions.awaitdata === 'boolean') {
      newOptions.awaitData = newOptions.awaitdata;
    ***REMOVED***

    // Translate to new command option noCursorTimeout
    if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = newOptions.timeout;

    // Merge in options to command
    for (let name in newOptions) {
      if (newOptions[name] != null && name !== 'session') {
        findCommand[name] = newOptions[name];
      ***REMOVED***
    ***REMOVED***

    if (projection) findCommand.fields = projection;

    // Add db object to the new options
    newOptions.db = this.s.db;

    // Add the promise library
    newOptions.promiseLibrary = this.s.promiseLibrary;

    // Set raw if available at collection level
    if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw;
    // Set promoteLongs if available at collection level
    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean')
      newOptions.promoteLongs = this.s.promoteLongs;
    if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean')
      newOptions.promoteValues = this.s.promoteValues;
    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean')
      newOptions.promoteBuffers = this.s.promoteBuffers;

    // Sort options
    if (findCommand.sort) {
      findCommand.sort = formattedOrderClause(findCommand.sort);
    ***REMOVED***

    // Set the readConcern
    decorateWithReadConcern(findCommand, this, options);

    // Decorate find command with collation options
    decorateWithCollation(findCommand, this, options);

    const cursor = this.s.topology.cursor(this.s.namespace, findCommand, newOptions);

    return typeof callback === 'function' ? handleCallback(callback, null, cursor) : cursor;
  ***REMOVED***
);

/**
 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object***REMOVED*** doc Document to insert.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~insertOneWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertOne = function(doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, insertOne, [this, doc, options, callback]);
***REMOVED***;

function mapInsertManyResults(docs, r) {
  const finalResult = {
    result: { ok: 1, n: r.insertedCount ***REMOVED***,
    ops: docs,
    insertedCount: r.insertedCount,
    insertedIds: r.insertedIds
  ***REMOVED***;

  if (r.getLastOp()) {
    finalResult.result.opTime = r.getLastOp();
  ***REMOVED***

  return finalResult;
***REMOVED***

/**
 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object[]***REMOVED*** docs Documents to insert.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {boolean***REMOVED*** [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertMany = function(docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options ? Object.assign({***REMOVED***, options) : { ordered: true ***REMOVED***;

  if (!Array.isArray(docs) && typeof callback === 'function') {
    return callback(
      MongoError.create({ message: 'docs parameter must be an array of documents', driver: true ***REMOVED***)
    );
  ***REMOVED*** else if (!Array.isArray(docs)) {
    return new this.s.promiseLibrary((resolve, reject) => {
      reject(
        MongoError.create({ message: 'docs parameter must be an array of documents', driver: true ***REMOVED***)
      );
    ***REMOVED***);
  ***REMOVED***

  // If keep going set unordered
  options['serializeFunctions'] = options['serializeFunctions'] || this.s.serializeFunctions;

  docs = prepareDocs(this, docs, options);

  // Generate the bulk write operations
  const operations = [
    {
      insertMany: docs
    ***REMOVED***
  ];

  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback], {
    resultMutator: result => mapInsertManyResults(docs, result)
  ***REMOVED***);
***REMOVED***;

/**
 * @typedef {Object***REMOVED*** Collection~BulkWriteOpResult
 * @property {number***REMOVED*** insertedCount Number of documents inserted.
 * @property {number***REMOVED*** matchedCount Number of documents matched for update.
 * @property {number***REMOVED*** modifiedCount Number of documents modified.
 * @property {number***REMOVED*** deletedCount Number of documents deleted.
 * @property {number***REMOVED*** upsertedCount Number of documents upserted.
 * @property {object***REMOVED*** insertedIds Inserted document generated Id's, hash key is the index of the originating operation
 * @property {object***REMOVED*** upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
 * @property {object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~bulkWriteOpCallback
 * @param {BulkWriteError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~BulkWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Perform a bulkWrite operation without a fluent API
 *
 * Legal operation types are
 *
 *  { insertOne: { document: { a: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  { updateOne: { filter: {a:2***REMOVED***, update: {$set: {a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  { updateMany: { filter: {a:2***REMOVED***, update: {$set: {a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  { deleteOne: { filter: {c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  { deleteMany: { filter: {c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  { replaceOne: { filter: {c:3***REMOVED***, replacement: {c:4***REMOVED***, upsert:true***REMOVED******REMOVED***
 *
 * If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {object[]***REMOVED*** operations Bulk operations to perform.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean***REMOVED*** [options.ordered=true] Execute write operation in ordered or unordered fashion.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~bulkWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.bulkWrite = function(operations, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || { ordered: true ***REMOVED***;

  if (!Array.isArray(operations)) {
    throw MongoError.create({ message: 'operations must be an array of documents', driver: true ***REMOVED***);
  ***REMOVED***

  return executeOperation(this.s.topology, bulkWrite, [this, operations, options, callback]);
***REMOVED***;

/**
 * @typedef {Object***REMOVED*** Collection~WriteOpResult
 * @property {object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property {object***REMOVED*** connection The connection object used for the operation.
 * @property {object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~writeOpCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~WriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * @typedef {Object***REMOVED*** Collection~insertWriteOpResult
 * @property {Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property {object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property {Object.<Number, ObjectId>***REMOVED*** insertedIds Map of the index of the inserted document to the id of the inserted document.
 * @property {object***REMOVED*** connection The connection object used for the operation.
 * @property {object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property {Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property {Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * @typedef {Object***REMOVED*** Collection~insertOneWriteOpResult
 * @property {Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property {object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property {ObjectId***REMOVED*** insertedId The driver generated ObjectId for the insert operation.
 * @property {object***REMOVED*** connection The connection object used for the operation.
 * @property {object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property {Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property {Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertWriteOpCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~insertWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertOneWriteOpCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~insertOneWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param {(object|object[])***REMOVED*** docs Documents to insert.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use insertOne, insertMany or bulkWrite
 */
Collection.prototype.insert = deprecate(function(docs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || { ordered: false ***REMOVED***;
  docs = !Array.isArray(docs) ? [docs] : docs;

  if (options.keepGoing === true) {
    options.ordered = false;
  ***REMOVED***

  return this.insertMany(docs, options, callback);
***REMOVED***, 'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');

/**
 * @typedef {Object***REMOVED*** Collection~updateWriteOpResult
 * @property {Object***REMOVED*** result The raw result returned from MongoDB. Will vary depending on server version.
 * @property {Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property {Number***REMOVED*** result.n The total count of documents scanned.
 * @property {Number***REMOVED*** result.nModified The total count of documents modified.
 * @property {Object***REMOVED*** connection The connection object used for the operation.
 * @property {Number***REMOVED*** matchedCount The number of documents that matched the filter.
 * @property {Number***REMOVED*** modifiedCount The number of documents that were modified.
 * @property {Number***REMOVED*** upsertedCount The number of documents upserted.
 * @property {Object***REMOVED*** upsertedId The upserted id.
 * @property {ObjectId***REMOVED*** upsertedId._id The upserted _id returned from the server.
 * @property {Object***REMOVED*** message
 * @property {Array***REMOVED*** ops
 */

/**
 * The callback format for inserts
 * @callback Collection~updateWriteOpCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~updateWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Update a single document in a collection
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to update
 * @param {object***REMOVED*** update The update operations to be applied to the document
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {Array***REMOVED*** [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateOne = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  ***REMOVED***

  options = Object.assign({***REMOVED***, options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateOne, [this, filter, update, options, callback]);
***REMOVED***;

/**
 * Replace a document in a collection with another document
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to replace
 * @param {object***REMOVED*** doc The Document that replaces the matching document
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise<Collection~updatewriteOpResultObject>***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.replaceOne = function(filter, doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = Object.assign({***REMOVED***, options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, replaceOne, [this, filter, doc, options, callback]);
***REMOVED***;

/**
 * Update multiple documents in a collection
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the documents to update
 * @param {object***REMOVED*** update The update operations to be applied to the documents
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {Array***REMOVED*** [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise<Collection~updateWriteOpResultObject>***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateMany = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  ***REMOVED***

  options = Object.assign({***REMOVED***, options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateMany, [this, filter, update, options, callback]);
***REMOVED***;

/**
 * Updates documents.
 * @method
 * @param {object***REMOVED*** selector The selector for the update operation.
 * @param {object***REMOVED*** document The update document.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param {boolean***REMOVED*** [options.multi=false] Update one/all documents with operation.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {Array***REMOVED*** [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @throws {MongoError***REMOVED***
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use updateOne, updateMany or bulkWrite
 */
Collection.prototype.update = deprecate(function(selector, document, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, updateDocuments, [
    this,
    selector,
    document,
    options,
    callback
  ]);
***REMOVED***, 'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');

/**
 * @typedef {Object***REMOVED*** Collection~deleteWriteOpResult
 * @property {Object***REMOVED*** result The raw result returned from MongoDB. Will vary depending on server version.
 * @property {Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property {Number***REMOVED*** result.n The total count of documents deleted.
 * @property {Object***REMOVED*** connection The connection object used for the operation.
 * @property {Number***REMOVED*** deletedCount The number of documents deleted.
 */

/**
 * The callback format for inserts
 * @callback Collection~deleteWriteOpCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~deleteWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Delete a document from a collection
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to remove
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteOne = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = Object.assign({***REMOVED***, options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, deleteOne, [this, filter, options, callback]);
***REMOVED***;

Collection.prototype.removeOne = Collection.prototype.deleteOne;

/**
 * Delete multiple documents from a collection
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the documents to remove
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteMany = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = Object.assign({***REMOVED***, options);

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, deleteMany, [this, filter, options, callback]);
***REMOVED***;

Collection.prototype.removeMany = Collection.prototype.deleteMany;

/**
 * Remove documents.
 * @method
 * @param {object***REMOVED*** selector The selector for the update operation.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.single=false] Removes the first document found.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use deleteOne, deleteMany or bulkWrite
 */
Collection.prototype.remove = deprecate(function(selector, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, removeDocuments, [this, selector, options, callback]);
***REMOVED***, 'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');

/**
 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
 * operators and update instead for more efficient operations.
 * @method
 * @param {object***REMOVED*** doc Document to save
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use insertOne, insertMany, updateOne or updateMany
 */
Collection.prototype.save = deprecate(function(doc, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Add ignoreUndfined
  if (this.s.options.ignoreUndefined) {
    options = Object.assign({***REMOVED***, options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  return executeOperation(this.s.topology, save, [this, doc, options, callback]);
***REMOVED***, 'collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.');

/**
 * The callback format for results
 * @callback Collection~resultCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {object***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * The callback format for an aggregation call
 * @callback Collection~aggregationCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {AggregationCursor***REMOVED*** cursor The cursor if the aggregation command was executed successfully.
 */

/**
 * Fetches the first document that matches the query
 * @method
 * @param {object***REMOVED*** query Query for find Operation
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {number***REMOVED*** [options.limit=0] Sets the limit of documents returned in the query.
 * @param {(array|object)***REMOVED*** [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param {object***REMOVED*** [options.projection] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1***REMOVED***
 * @param {object***REMOVED*** [options.fields] **Deprecated** Use `options.projection` instead
 * @param {number***REMOVED*** [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param {Object***REMOVED*** [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1***REMOVED***
 * @param {boolean***REMOVED*** [options.explain=false] Explain the query instead of returning the data.
 * @param {boolean***REMOVED*** [options.snapshot=false] DEPRECATED: Snapshot query.
 * @param {boolean***REMOVED*** [options.timeout=false] Specify if the cursor can timeout.
 * @param {boolean***REMOVED*** [options.tailable=false] Specify if the cursor is tailable.
 * @param {number***REMOVED*** [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {boolean***REMOVED*** [options.returnKey=false] Only return the index key.
 * @param {number***REMOVED*** [options.maxScan] DEPRECATED: Limit the number of items to scan.
 * @param {number***REMOVED*** [options.min] Set index bounds.
 * @param {number***REMOVED*** [options.max] Set index bounds.
 * @param {boolean***REMOVED*** [options.showDiskLoc=false] Show disk location of results.
 * @param {string***REMOVED*** [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param {boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean***REMOVED*** [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOne = deprecateOptions(
  {
    name: 'collection.find',
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  ***REMOVED***,
  function(query, options, callback) {
    if (typeof callback === 'object') {
      // TODO(MAJOR): throw in the future
      console.warn('Third parameter to `findOne()` must be a callback or undefined');
    ***REMOVED***

    if (typeof query === 'function') (callback = query), (query = {***REMOVED***), (options = {***REMOVED***);
    if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
    query = query || {***REMOVED***;
    options = options || {***REMOVED***;

    return executeOperation(this.s.topology, findOne, [this, query, options, callback]);
  ***REMOVED***
);

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Collection~collectionResultCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection***REMOVED*** collection The collection instance.
 */

/**
 * Rename the collection.
 *
 * @method
 * @param {string***REMOVED*** newName New name of of the collection.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.rename = function(newName, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = Object.assign({***REMOVED***, options, { readPreference: ReadPreference.PRIMARY ***REMOVED***);

  return executeOperation(this.s.topology, rename, [this, newName, options, callback]);
***REMOVED***;

/**
 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.drop = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, this.s.db.dropCollection.bind(this.s.db), [
    this.s.name,
    options,
    callback
  ]);
***REMOVED***;

/**
 * Returns the options of the collection.
 *
 * @method
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.options = function(opts, callback) {
  if (typeof opts === 'function') (callback = opts), (opts = {***REMOVED***);
  opts = opts || {***REMOVED***;

  return executeOperation(this.s.topology, optionsOp, [this, opts, callback]);
***REMOVED***;

/**
 * Returns if the collection is a capped collection
 *
 * @method
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.isCapped = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, isCapped, [this, options, callback]);
***REMOVED***;

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param {(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param {boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param {boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param {boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param {number***REMOVED*** [options.min] For geospatial indexes set the lower bound for the co-ordinates.
 * @param {number***REMOVED*** [options.max] For geospatial indexes set the high bound for the co-ordinates.
 * @param {number***REMOVED*** [options.v] Specify the format version of the indexes.
 * @param {number***REMOVED*** [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param {string***REMOVED*** [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param {object***REMOVED*** [options.partialFilterExpression] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, createIndex, [this, fieldOrSpec, options, callback]);
***REMOVED***;

/**
 * Creates multiple indexes in the collection, this method is only supported for
 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
 * @method
 * @param {array***REMOVED*** indexSpecs An array of index specifications to be created
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndexes = function(indexSpecs, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);

  options = options ? Object.assign({***REMOVED***, options) : {***REMOVED***;
  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;

  return executeOperation(this.s.topology, createIndexes, [this, indexSpecs, options, callback]);
***REMOVED***;

/**
 * Drops an index from this collection.
 * @method
 * @param {string***REMOVED*** indexName Name of the index to drop.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndex = function(indexName, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;

  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;
  // Run only against primary
  options.readPreference = ReadPreference.PRIMARY;

  return executeOperation(this.s.topology, dropIndex, [this, indexName, options, callback]);
***REMOVED***;

/**
 * Drops all indexes from this collection.
 * @method
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndexes = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options ? Object.assign({***REMOVED***, options) : {***REMOVED***;

  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;

  return executeOperation(this.s.topology, dropIndexes, [this, options, callback]);
***REMOVED***;

/**
 * Drops all indexes from this collection.
 * @method
 * @deprecated use dropIndexes
 * @param {Collection~resultCallback***REMOVED*** callback The command result callback
 * @return {Promise***REMOVED*** returns Promise if no [callback] passed
 */
Collection.prototype.dropAllIndexes = deprecate(
  Collection.prototype.dropIndexes,
  'collection.dropAllIndexes is deprecated. Use dropIndexes instead.'
);

/**
 * Reindex all indexes on the collection
 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
 * @method
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.reIndex = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, reIndex, [this, options, callback]);
***REMOVED***;

/**
 * Get the list of all indexes information for the collection.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {number***REMOVED*** [options.batchSize] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return {CommandCursor***REMOVED***
 */
Collection.prototype.listIndexes = function(options) {
  options = options || {***REMOVED***;
  // Clone the options
  options = Object.assign({***REMOVED***, options);
  // Determine the read preference in the options.
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this ***REMOVED***);
  // Set the CommandCursor constructor
  options.cursorFactory = CommandCursor;
  // Set the promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  if (!this.s.topology.capabilities()) {
    throw new MongoError('cannot connect to server');
  ***REMOVED***

  // Cursor options
  let cursor = options.batchSize ? { batchSize: options.batchSize ***REMOVED*** : {***REMOVED***;

  // We have a list collections command
  if (this.s.topology.capabilities().hasListIndexesCommand) {
    // Build the command
    const command = { listIndexes: this.s.name, cursor: cursor ***REMOVED***;
    // Execute the cursor
    cursor = this.s.topology.cursor(`${this.s.dbName***REMOVED***.$cmd`, command, options);
    // Do we have a readPreference, apply it
    if (options.readPreference) cursor.setReadPreference(options.readPreference);
    // Return the cursor
    return cursor;
  ***REMOVED***

  // Get the namespace
  const ns = `${this.s.dbName***REMOVED***.system.indexes`;
  // Get the query
  cursor = this.s.topology.cursor(ns, { find: ns, query: { ns: this.s.namespace ***REMOVED*** ***REMOVED***, options);
  // Do we have a readPreference, apply it
  if (options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // Return the cursor
  return cursor;
***REMOVED***;

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated use createIndexes instead
 * @param {(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param {boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param {boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param {boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param {number***REMOVED*** [options.min] For geospatial indexes set the lower bound for the co-ordinates.
 * @param {number***REMOVED*** [options.max] For geospatial indexes set the high bound for the co-ordinates.
 * @param {number***REMOVED*** [options.v] Specify the format version of the indexes.
 * @param {number***REMOVED*** [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param {number***REMOVED*** [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, ensureIndex, [this, fieldOrSpec, options, callback]);
***REMOVED***, 'collection.ensureIndex is deprecated. Use createIndexes instead.');

/**
 * Checks if one or more indexes exist on the collection, fails on first non-existing index
 * @method
 * @param {(string|array)***REMOVED*** indexes One or more index names to check.
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexExists = function(indexes, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, indexExists, [this, indexes, options, callback]);
***REMOVED***;

/**
 * Retrieves this collections index info.
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.full=false] Returns the full raw index information.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexInformation = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, indexInformation, [this, options, callback]);
***REMOVED***;

/**
 * The callback format for results
 * @callback Collection~countCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {number***REMOVED*** result The count of documents that matched the query.
 */

/**
 * Count number of matching documents in the db to a query.
 * @method
 * @param {object***REMOVED*** [query={***REMOVED***] The query for the count.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.limit] The limit of documents to count.
 * @param {boolean***REMOVED*** [options.skip] The number of documents to skip for the count.
 * @param {string***REMOVED*** [options.hint] An index name hint for the query.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~countCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use {@link Collection#countDocuments countDocuments***REMOVED*** or {@link Collection#estimatedDocumentCount estimatedDocumentCount***REMOVED*** instead
 */
Collection.prototype.count = deprecate(function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, count, [this, query, options, callback]);
***REMOVED***, 'collection.count is deprecated, and will be removed in a future version.' +
  ' Use collection.countDocuments or collection.estimatedDocumentCount instead');

/**
 * Gets an estimate of the count of documents in a collection using collection metadata.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {number***REMOVED*** [options.maxTimeMS] The maximum amount of time to allow the operation to run.
 * @param {Collection~countCallback***REMOVED*** [callback] The command result callback.
 * @return {Promise***REMOVED*** returns Promise if no callback passed.
 */
Collection.prototype.estimatedDocumentCount = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  options = typeof options.maxTimeMS === 'number' ? options : {***REMOVED***;

  return executeOperation(this.s.topology, count, [this, null, options, callback]);
***REMOVED***;

/**
 * Gets the number of documents matching the filter.
 *
 * **Note**: When migrating from {@link Collection#count count***REMOVED*** to {@link Collection#countDocuments countDocuments***REMOVED***
 * the following query operators must be replaced:
 *
 * | Operator | Replacement |
 * | -------- | ----------- |
 * | `$where`   | [`$expr`][1] |
 * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
 * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
 *
 * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/
 * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
 * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
 * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
 *
 * @param {object***REMOVED*** [query] the query for the count
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {object***REMOVED*** [options.collation] Specifies a collation.
 * @param {string|object***REMOVED*** [options.hint] The index to use.
 * @param {number***REMOVED*** [options.limit] The maximum number of document to count.
 * @param {number***REMOVED*** [options.maxTimeMS] The maximum amount of time to allow the operation to run.
 * @param {number***REMOVED*** [options.skip] The number of documents to skip before counting.
 * @param {Collection~countCallback***REMOVED*** [callback] The command result callback.
 * @return {Promise***REMOVED*** returns Promise if no callback passed.
 * @see https://docs.mongodb.com/manual/reference/operator/query/expr/
 * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
 * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
 * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
 */

Collection.prototype.countDocuments = function(query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  query = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, countDocuments, [this, query, options, callback]);
***REMOVED***;

/**
 * The distinct command returns returns a list of distinct values for the given key across a collection.
 * @method
 * @param {string***REMOVED*** key Field of the document to find distinct values for.
 * @param {object***REMOVED*** query The query for filtering the set of documents to which we apply the distinct filter.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number***REMOVED*** [options.maxTimeMS] Number of miliseconds to wait before aborting the query.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.distinct = function(key, query, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  const queryOption = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;
  const optionsOption = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, distinct, [
    this,
    key,
    queryOption,
    optionsOption,
    callback
  ]);
***REMOVED***;

/**
 * Retrieve all the indexes on the collection.
 * @method
 * @param {Object***REMOVED*** [options] Optional settings
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexes = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  return executeOperation(this.s.topology, indexes, [this, options, callback]);
***REMOVED***;

/**
 * Get all the collection statistics.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {number***REMOVED*** [options.scale] Divide the returned sizes by scale value.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The collection result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.stats = function(options, callback) {
  const args = Array.prototype.slice.call(arguments, 0);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, stats, [this, options, callback]);
***REMOVED***;

/**
 * @typedef {Object***REMOVED*** Collection~findAndModifyWriteOpResult
 * @property {object***REMOVED*** value Document returned from findAndModify command.
 * @property {object***REMOVED*** lastErrorObject The raw lastErrorObject returned from the command.
 * @property {Number***REMOVED*** ok Is 1 if the command executed correctly.
 */

/**
 * The callback format for inserts
 * @callback Collection~findAndModifyCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Collection~findAndModifyWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to remove
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {object***REMOVED*** [options.projection] Limits the fields to return for all matching documents.
 * @param {object***REMOVED*** [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number***REMOVED*** [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndDelete = function(filter, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');

  return executeOperation(this.s.topology, findOneAndDelete, [this, filter, options, callback]);
***REMOVED***;

/**
 * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to replace
 * @param {object***REMOVED*** replacement The Document that replaces the matching document
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {object***REMOVED*** [options.projection] Limits the fields to return for all matching documents.
 * @param {object***REMOVED*** [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number***REMOVED*** [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (replacement == null || typeof replacement !== 'object')
    throw toError('replacement parameter must be an object');

  return executeOperation(this.s.topology, findOneAndReplace, [
    this,
    filter,
    replacement,
    options,
    callback
  ]);
***REMOVED***;

/**
 * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object***REMOVED*** filter The Filter used to select the document to update
 * @param {object***REMOVED*** update Update operations to be performed on the document
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {object***REMOVED*** [options.projection] Limits the fields to return for all matching documents.
 * @param {object***REMOVED*** [options.sort] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number***REMOVED*** [options.maxTimeMS] The maximum amount of time to allow the query to run.
 * @param {boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Array***REMOVED*** [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return {Promise<Collection~findAndModifyWriteOpResultObject>***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = options || {***REMOVED***;

  // Basic validation
  if (filter == null || typeof filter !== 'object')
    throw toError('filter parameter must be an object');
  if (update == null || typeof update !== 'object')
    throw toError('update parameter must be an object');

  const err = checkForAtomicOperators(update);
  if (err) {
    if (typeof callback === 'function') return callback(err);
    return this.s.promiseLibrary.reject(err);
  ***REMOVED***

  return executeOperation(this.s.topology, findOneAndUpdate, [
    this,
    filter,
    update,
    options,
    callback
  ]);
***REMOVED***;

/**
 * Find and update a document.
 * @method
 * @param {object***REMOVED*** query Query object to locate the object to modify.
 * @param {array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object***REMOVED*** doc The fields/vals to be updated.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {boolean***REMOVED*** [options.remove=false] Set to true to remove the object before returning.
 * @param {boolean***REMOVED*** [options.upsert=false] Perform an upsert operation.
 * @param {boolean***REMOVED*** [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
 * @param {object***REMOVED*** [options.projection] Object containing the field projection for the result returned from the operation.
 * @param {object***REMOVED*** [options.fields] **Deprecated** Use `options.projection` instead
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Array***REMOVED*** [options.arrayFilters] optional list of array filters referenced in filtered positional operators
 * @param {Collection~findAndModifyCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
Collection.prototype.findAndModify = deprecate(function(query, sort, doc, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  // Clone options
  options = Object.assign({***REMOVED***, options);
  // Force read preference primary
  options.readPreference = ReadPreference.PRIMARY;

  return executeOperation(this.s.topology, findAndModify, [
    this,
    query,
    sort,
    doc,
    options,
    callback
  ]);
***REMOVED***, 'collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.');

/**
 * Find and remove a document.
 * @method
 * @param {object***REMOVED*** query Query object to locate the object to modify.
 * @param {array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndDelete instead
 */
Collection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
  const args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, findAndRemove, [this, query, sort, options, callback]);
***REMOVED***, 'collection.findAndRemove is deprecated. Use findOneAndDelete instead.');

/**
 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
 * @method
 * @param {object***REMOVED*** [pipeline=[]] Array containing all the aggregation framework commands for the execution.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object***REMOVED*** [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
 * @param {number***REMOVED*** [options.cursor.batchSize] The batchSize for the cursor
 * @param {boolean***REMOVED*** [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
 * @param {boolean***REMOVED*** [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
 * @param {number***REMOVED*** [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param {boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param {boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param {boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param {object***REMOVED*** [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param {string***REMOVED*** [options.comment] Add a comment to an aggregation command
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~aggregationCallback***REMOVED*** callback The command result callback
 * @return {(null|AggregationCursor)***REMOVED***
 */
Collection.prototype.aggregate = function(pipeline, options, callback) {
  if (Array.isArray(pipeline)) {
    // Set up callback if one is provided
    if (typeof options === 'function') {
      callback = options;
      options = {***REMOVED***;
    ***REMOVED***

    // If we have no options or callback we are doing
    // a cursor based aggregation
    if (options == null && callback == null) {
      options = {***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    // Aggregation pipeline passed as arguments on the method
    const args = Array.prototype.slice.call(arguments, 0);
    // Get the callback
    callback = args.pop();
    // Get the possible options object
    const opts = args[args.length - 1];
    // If it contains any of the admissible options pop it of the args
    options =
      opts &&
      (opts.readPreference ||
        opts.explain ||
        opts.cursor ||
        opts.out ||
        opts.maxTimeMS ||
        opts.hint ||
        opts.allowDiskUse)
        ? args.pop()
        : {***REMOVED***;
    // Left over arguments is the pipeline
    pipeline = args;
  ***REMOVED***

  // Ignore readConcern option
  let ignoreReadConcern = false;

  // Build the command
  const command = { aggregate: this.s.name, pipeline: pipeline ***REMOVED***;

  // If out was specified
  if (typeof options.out === 'string') {
    pipeline.push({ $out: options.out ***REMOVED***);
    // Ignore read concern
    ignoreReadConcern = true;
  ***REMOVED*** else if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
    ignoreReadConcern = true;
  ***REMOVED***

  // Decorate command with writeConcern if out has been specified
  if (
    pipeline.length > 0 &&
    pipeline[pipeline.length - 1]['$out'] &&
    this.s.topology.capabilities().commandsTakeWriteConcern
  ) {
    applyWriteConcern(command, { db: this.s.db, collection: this ***REMOVED***, options);
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(command, this, options);

  // If we have bypassDocumentValidation set
  if (options.bypassDocumentValidation === true) {
    command.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Do we have a readConcern specified
  if (!ignoreReadConcern) {
    decorateWithReadConcern(command, this, options);
  ***REMOVED***

  // If we have allowDiskUse defined
  if (options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
  if (typeof options.maxTimeMS === 'number') command.maxTimeMS = options.maxTimeMS;

  // If we are giving a hint
  if (options.hint) command.hint = options.hint;

  options = Object.assign({***REMOVED***, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this ***REMOVED***);

  // If explain has been specified add it
  if (options.explain) {
    if (command.readConcern || command.writeConcern) {
      throw toError('"explain" cannot be used on an aggregate call with readConcern/writeConcern');
    ***REMOVED***
    command.explain = options.explain;
  ***REMOVED***

  if (typeof options.comment === 'string') command.comment = options.comment;

  // Validate that cursor options is valid
  if (options.cursor != null && typeof options.cursor !== 'object') {
    throw toError('cursor options must be an object');
  ***REMOVED***

  options.cursor = options.cursor || {***REMOVED***;
  if (options.batchSize) options.cursor.batchSize = options.batchSize;
  command.cursor = options.cursor;

  // promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Set the AggregationCursor constructor
  options.cursorFactory = AggregationCursor;
  if (typeof callback !== 'function') {
    if (!this.s.topology.capabilities()) {
      throw new MongoError('cannot connect to server');
    ***REMOVED***

    // Allow disk usage command
    if (typeof options.allowDiskUse === 'boolean') command.allowDiskUse = options.allowDiskUse;
    if (typeof options.maxTimeMS === 'number') command.maxTimeMS = options.maxTimeMS;

    // Execute the cursor
    return this.s.topology.cursor(this.s.namespace, command, options);
  ***REMOVED***

  return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, command, options));
***REMOVED***;

/**
 * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
 * @method
 * @since 3.0.0
 * @param {Array***REMOVED*** [pipeline] An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages***REMOVED*** through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
 * @param {object***REMOVED*** [options] Optional settings
 * @param {string***REMOVED*** [options.fullDocument='default'] Allowed values: default, updateLookup. When set to updateLookup, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @param {object***REMOVED*** [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.
 * @param {number***REMOVED*** [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query
 * @param {number***REMOVED*** [options.batchSize] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param {object***REMOVED*** [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation***REMOVED***.
 * @param {ReadPreference***REMOVED*** [options.readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation***REMOVED***.
 * @param {Timestamp***REMOVED*** [options.startAtClusterTime] receive change events that occur after the specified timestamp
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return {ChangeStream***REMOVED*** a ChangeStream instance.
 */
Collection.prototype.watch = function(pipeline, options) {
  pipeline = pipeline || [];
  options = options || {***REMOVED***;

  // Allow optionally not specifying a pipeline
  if (!Array.isArray(pipeline)) {
    options = pipeline;
    pipeline = [];
  ***REMOVED***

  return new ChangeStream(this, pipeline, options);
***REMOVED***;

/**
 * The callback format for results
 * @callback Collection~parallelCollectionScanCallback
 * @param {MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param {Cursor[]***REMOVED*** cursors A list of cursors returned allowing for parallel reading of collection.
 */

/**
 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
 * no ordering guarantees for returned results.
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number***REMOVED*** [options.batchSize] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {number***REMOVED*** [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
 * @param {boolean***REMOVED*** [options.raw=false] Return all BSON documents as Raw Buffer documents.
 * @param {Collection~parallelCollectionScanCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.parallelCollectionScan = function(options, callback) {
  if (typeof options === 'function') (callback = options), (options = { numCursors: 1 ***REMOVED***);
  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  options = Object.assign({***REMOVED***, options);
  // Ensure we have the right read preference inheritance
  options.readPreference = resolveReadPreference(options, { db: this.s.db, collection: this ***REMOVED***);

  // Add a promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  if (options.session) {
    options.session = undefined;
  ***REMOVED***

  return executeOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {
    skipSessions: true
  ***REMOVED***);
***REMOVED***;

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param {number***REMOVED*** x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param {number***REMOVED*** y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {number***REMOVED*** [options.maxDistance] Include results up to maxDistance from the point.
 * @param {object***REMOVED*** [options.search] Filter the results by a query.
 * @param {number***REMOVED*** [options.limit=false] Max number of results to return.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
  const args = Array.prototype.slice.call(arguments, 2);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  return executeOperation(this.s.topology, geoHaystackSearch, [this, x, y, options, callback]);
***REMOVED***;

/**
 * Run a group command across a collection
 *
 * @method
 * @param {(object|array|function|code)***REMOVED*** keys An object, array or function expressing the keys to group by.
 * @param {object***REMOVED*** condition An optional condition that must be true for a row to be considered.
 * @param {object***REMOVED*** initial Initial value of the aggregation counter object.
 * @param {(function|Code)***REMOVED*** reduce The reduce function aggregates (reduces) the objects iterated
 * @param {(function|Code)***REMOVED*** finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param {boolean***REMOVED*** command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.
 */
Collection.prototype.group = deprecate(function(
  keys,
  condition,
  initial,
  reduce,
  finalize,
  command,
  options,
  callback
) {
  const args = Array.prototype.slice.call(arguments, 3);
  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {***REMOVED*** : {***REMOVED***;

  // Make sure we are backward compatible
  if (!(typeof finalize === 'function')) {
    command = finalize;
    finalize = null;
  ***REMOVED***

  if (
    !Array.isArray(keys) &&
    keys instanceof Object &&
    typeof keys !== 'function' &&
    !(keys._bsontype === 'Code')
  ) {
    keys = Object.keys(keys);
  ***REMOVED***

  if (typeof reduce === 'function') {
    reduce = reduce.toString();
  ***REMOVED***

  if (typeof finalize === 'function') {
    finalize = finalize.toString();
  ***REMOVED***

  // Set up the command as default
  command = command == null ? true : command;

  return executeOperation(this.s.topology, group, [
    this,
    keys,
    condition,
    initial,
    reduce,
    finalize,
    command,
    options,
    callback
  ]);
***REMOVED***,
'MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.');

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param {(function|string)***REMOVED*** map The mapping function.
 * @param {(function|string)***REMOVED*** reduce The reduce function.
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(ReadPreference|string)***REMOVED*** [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object***REMOVED*** [options.out] Sets the output target for the map reduce job. *{inline:1***REMOVED*** | {replace:'collectionName'***REMOVED*** | {merge:'collectionName'***REMOVED*** | {reduce:'collectionName'***REMOVED****
 * @param {object***REMOVED*** [options.query] Query filter object.
 * @param {object***REMOVED*** [options.sort] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
 * @param {number***REMOVED*** [options.limit] Number of objects to return from collection.
 * @param {boolean***REMOVED*** [options.keeptemp=false] Keep temporary data.
 * @param {(function|string)***REMOVED*** [options.finalize] Finalize function.
 * @param {object***REMOVED*** [options.scope] Can pass in variables that can be access from map/reduce/finalize.
 * @param {boolean***REMOVED*** [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
 * @param {boolean***REMOVED*** [options.verbose=false] Provide statistics on job execution time.
 * @param {boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @throws {MongoError***REMOVED***
 * @return {Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.mapReduce = function(map, reduce, options, callback) {
  if ('function' === typeof options) (callback = options), (options = {***REMOVED***);
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
  if (null == options.out) {
    throw new Error(
      'the out option parameter must be defined, see mongodb docs for possible values'
    );
  ***REMOVED***

  if ('function' === typeof map) {
    map = map.toString();
  ***REMOVED***

  if ('function' === typeof reduce) {
    reduce = reduce.toString();
  ***REMOVED***

  if ('function' === typeof options.finalize) {
    options.finalize = options.finalize.toString();
  ***REMOVED***

  return executeOperation(this.s.topology, mapReduce, [this, map, reduce, options, callback]);
***REMOVED***;

/**
 * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @return {UnorderedBulkOperation***REMOVED***
 */
Collection.prototype.initializeUnorderedBulkOp = function(options) {
  options = options || {***REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
***REMOVED***;

/**
 * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
 *
 * @method
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {(number|string)***REMOVED*** [options.w] The write concern.
 * @param {number***REMOVED*** [options.wtimeout] The write concern timeout.
 * @param {boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param {ClientSession***REMOVED*** [options.session] optional session to use for this operation
 * @param {OrderedBulkOperation***REMOVED*** callback The command result callback
 * @return {null***REMOVED***
 */
Collection.prototype.initializeOrderedBulkOp = function(options) {
  options = options || {***REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
***REMOVED***;

/**
 * Return the db logger
 * @method
 * @return {Logger***REMOVED*** return the db logger
 * @ignore
 */
Collection.prototype.getLogger = function() {
  return this.s.db.s.logger;
***REMOVED***;

module.exports = Collection;
