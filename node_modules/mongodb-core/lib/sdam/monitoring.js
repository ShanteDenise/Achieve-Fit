'use strict';

const ServerDescription = require('./server_description').ServerDescription;
const calculateDurationInMs = require('../utils').calculateDurationInMs;

/**
 * Published when server description changes, but does NOT include changes to the RTT.
 *
 * @property {Object***REMOVED*** topologyId A unique identifier for the topology
 * @property {ServerAddress***REMOVED*** address The address (host/port pair) of the server
 * @property {ServerDescription***REMOVED*** previousDescription The previous server description
 * @property {ServerDescription***REMOVED*** newDescription The new server description
 */
class ServerDescriptionChangedEvent {
  constructor(topologyId, address, previousDescription, newDescription) {
    Object.assign(this, { topologyId, address, previousDescription, newDescription ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Published when server is initialized.
 *
 * @property {Object***REMOVED*** topologyId A unique identifier for the topology
 * @property {ServerAddress***REMOVED*** address The address (host/port pair) of the server
 */
class ServerOpeningEvent {
  constructor(topologyId, address) {
    Object.assign(this, { topologyId, address ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Published when server is closed.
 *
 * @property {ServerAddress***REMOVED*** address The address (host/port pair) of the server
 * @property {Object***REMOVED*** topologyId A unique identifier for the topology
 */
class ServerClosedEvent {
  constructor(topologyId, address) {
    Object.assign(this, { topologyId, address ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Published when topology description changes.
 *
 * @property {Object***REMOVED*** topologyId
 * @property {TopologyDescription***REMOVED*** previousDescription The old topology description
 * @property {TopologyDescription***REMOVED*** newDescription The new topology description
 */
class TopologyDescriptionChangedEvent {
  constructor(topologyId, previousDescription, newDescription) {
    Object.assign(this, { topologyId, previousDescription, newDescription ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Published when topology is initialized.
 *
 * @param {Object***REMOVED*** topologyId A unique identifier for the topology
 */
class TopologyOpeningEvent {
  constructor(topologyId) {
    Object.assign(this, { topologyId ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Published when topology is closed.
 *
 * @param {Object***REMOVED*** topologyId A unique identifier for the topology
 */
class TopologyClosedEvent {
  constructor(topologyId) {
    Object.assign(this, { topologyId ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Fired when the server monitor’s ismaster command is started - immediately before
 * the ismaster command is serialized into raw BSON and written to the socket.
 *
 * @property {Object***REMOVED*** connectionId The connection id for the command
 */
class ServerHeartbeatStartedEvent {
  constructor(connectionId) {
    Object.assign(this, { connectionId ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Fired when the server monitor’s ismaster succeeds.
 *
 * @param {Number***REMOVED*** duration The execution time of the event in ms
 * @param {Object***REMOVED*** reply The command reply
 * @param {Object***REMOVED*** connectionId The connection id for the command
 */
class ServerHeartbeatSucceededEvent {
  constructor(duration, reply, connectionId) {
    Object.assign(this, { duration, reply, connectionId ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Fired when the server monitor’s ismaster fails, either with an “ok: 0” or a socket exception.
 *
 * @param {Number***REMOVED*** duration The execution time of the event in ms
 * @param {MongoError|Object***REMOVED*** failure The command failure
 * @param {Object***REMOVED*** connectionId The connection id for the command
 */
class ServerHeartbeatFailedEvent {
  constructor(duration, failure, connectionId) {
    Object.assign(this, { duration, failure, connectionId ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Performs a server check as described by the SDAM spec.
 *
 * NOTE: This method automatically reschedules itself, so that there is always an active
 * monitoring process
 *
 * @param {Server***REMOVED*** server The server to monitor
 */
function monitorServer(server) {
  // executes a single check of a server
  const checkServer = callback => {
    let start = process.hrtime();

    // emit a signal indicating we have started the heartbeat
    server.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(server.name));

    server.command(
      'admin.$cmd',
      { ismaster: true ***REMOVED***,
      {
        monitoring: true,
        socketTimeout: server.s.options.connectionTimeout || 2000
      ***REMOVED***,
      function(err, result) {
        let duration = calculateDurationInMs(start);

        if (err) {
          server.emit(
            'serverHeartbeatFailed',
            new ServerHeartbeatFailedEvent(duration, err, server.name)
          );

          return callback(err, null);
        ***REMOVED***

        const isMaster = result.result;
        server.emit(
          'serverHeartbeatSucceded',
          new ServerHeartbeatSucceededEvent(duration, isMaster, server.name)
        );

        return callback(null, isMaster);
      ***REMOVED***
    );
  ***REMOVED***;

  const successHandler = isMaster => {
    server.s.monitoring = false;

    // emit an event indicating that our description has changed
    server.emit('descriptionReceived', new ServerDescription(server.description.address, isMaster));

    // schedule the next monitoring process
    server.s.monitorId = setTimeout(
      () => monitorServer(server),
      server.s.options.heartbeatFrequencyMS
    );
  ***REMOVED***;

  // run the actual monitoring loop
  server.s.monitoring = true;
  checkServer((err, isMaster) => {
    if (!err) {
      successHandler(isMaster);
      return;
    ***REMOVED***

    // According to the SDAM specification's "Network error during server check" section, if
    // an ismaster call fails we reset the server's pool. If a server was once connected,
    // change its type to `Unknown` only after retrying once.

    // TODO: we need to reset the pool here

    return checkServer((err, isMaster) => {
      if (err) {
        server.s.monitoring = false;

        // revert to `Unknown` by emitting a default description with no isMaster
        server.emit('descriptionReceived', new ServerDescription(server.description.address));

        // do not reschedule monitoring in this case
        return;
      ***REMOVED***

      successHandler(isMaster);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

module.exports = {
  ServerDescriptionChangedEvent,
  ServerOpeningEvent,
  ServerClosedEvent,
  TopologyDescriptionChangedEvent,
  TopologyOpeningEvent,
  TopologyClosedEvent,
  ServerHeartbeatStartedEvent,
  ServerHeartbeatSucceededEvent,
  ServerHeartbeatFailedEvent,
  monitorServer
***REMOVED***;
