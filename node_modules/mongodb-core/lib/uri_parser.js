'use strict';
const URL = require('url');
const qs = require('querystring');
const dns = require('dns');
const MongoParseError = require('./error').MongoParseError;
const ReadPreference = require('./topologies/read_preference');

/**
 * The following regular expression validates a connection string and breaks the
 * provide string into the following capture groups: [protocol, username, password, hosts]
 */
const HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;

/**
 * Determines whether a provided address matches the provided parent domain in order
 * to avoid certain attack vectors.
 *
 * @param {String***REMOVED*** srvAddress The address to check against a domain
 * @param {String***REMOVED*** parentDomain The domain to check the provided address against
 * @return {Boolean***REMOVED*** Whether the provided address matches the parent domain
 */
function matchesParentDomain(srvAddress, parentDomain) {
  const regex = /^.*?\./;
  const srv = `.${srvAddress.replace(regex, '')***REMOVED***`;
  const parent = `.${parentDomain.replace(regex, '')***REMOVED***`;
  return srv.endsWith(parent);
***REMOVED***

/**
 * Lookup an `mongodb+srv` connection string, combine the parts and reparse it as a normal
 * connection string.
 *
 * @param {string***REMOVED*** uri The connection string to parse
 * @param {object***REMOVED*** options Optional user provided connection string options
 * @param {function***REMOVED*** callback
 */
function parseSrvConnectionString(uri, options, callback) {
  const result = URL.parse(uri, true);

  if (result.hostname.split('.').length < 3) {
    return callback(new MongoParseError('URI does not have hostname, domain name and tld'));
  ***REMOVED***

  result.domainLength = result.hostname.split('.').length;
  if (result.pathname && result.pathname.match(',')) {
    return callback(new MongoParseError('Invalid URI, cannot contain multiple hostnames'));
  ***REMOVED***

  if (result.port) {
    return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV***REMOVED***' URIs`));
  ***REMOVED***

  let srvAddress = `_mongodb._tcp.${result.host***REMOVED***`;
  dns.resolveSrv(srvAddress, (err, addresses) => {
    if (err) return callback(err);

    if (addresses.length === 0) {
      return callback(new MongoParseError('No addresses found at host'));
    ***REMOVED***

    for (let i = 0; i < addresses.length; i++) {
      if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
        return callback(
          new MongoParseError('Server record does not share hostname with parent URI')
        );
      ***REMOVED***
    ***REMOVED***

    let base = result.auth ? `mongodb://${result.auth***REMOVED***@` : `mongodb://`;
    let connectionStrings = addresses.map(
      (address, i) =>
        i === 0 ? `${base***REMOVED***${address.name***REMOVED***:${address.port***REMOVED***` : `${address.name***REMOVED***:${address.port***REMOVED***`
    );

    let connectionString = `${connectionStrings.join(',')***REMOVED***/`;
    let connectionStringOptions = [];

    // Add the default database if needed
    if (result.path) {
      let defaultDb = result.path.slice(1);
      if (defaultDb.indexOf('?') !== -1) {
        defaultDb = defaultDb.slice(0, defaultDb.indexOf('?'));
      ***REMOVED***

      connectionString += defaultDb;
    ***REMOVED***

    // Default to SSL true
    if (!options.ssl && (!result.search || result.query['ssl'] == null)) {
      connectionStringOptions.push('ssl=true');
    ***REMOVED***

    // Keep original uri options
    if (result.search) {
      connectionStringOptions.push(result.search.replace('?', ''));
    ***REMOVED***

    dns.resolveTxt(result.host, (err, record) => {
      if (err) {
        if (err.code !== 'ENODATA') {
          return callback(err);
        ***REMOVED***
        record = null;
      ***REMOVED***

      if (record) {
        if (record.length > 1) {
          return callback(new MongoParseError('Multiple text records not allowed'));
        ***REMOVED***

        record = record[0];
        record = record.length > 1 ? record.join('') : record[0];
        if (record.indexOf('authSource') === -1 && record.indexOf('replicaSet') === -1) {
          return callback(
            new MongoParseError('Text record must only set `authSource` or `replicaSet`')
          );
        ***REMOVED***

        connectionStringOptions.push(record);
      ***REMOVED***

      // Add any options to the connection string
      if (connectionStringOptions.length) {
        connectionString += `?${connectionStringOptions.join('&')***REMOVED***`;
      ***REMOVED***

      parseConnectionString(connectionString, options, callback);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * Parses a query string item according to the connection string spec
 *
 * @param {string***REMOVED*** key The key for the parsed value
 * @param {Array|String***REMOVED*** value The value to parse
 * @return {Array|Object|String***REMOVED*** The parsed value
 */
function parseQueryStringItemValue(key, value) {
  if (Array.isArray(value)) {
    // deduplicate and simplify arrays
    value = value.filter((v, idx) => value.indexOf(v) === idx);
    if (value.length === 1) value = value[0];
  ***REMOVED*** else if (value.indexOf(':') > 0) {
    value = value.split(',').reduce((result, pair) => {
      const parts = pair.split(':');
      result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
      return result;
    ***REMOVED***, {***REMOVED***);
  ***REMOVED*** else if (value.indexOf(',') > 0) {
    value = value.split(',').map(v => {
      return parseQueryStringItemValue(key, v);
    ***REMOVED***);
  ***REMOVED*** else if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
    value = value.toLowerCase() === 'true';
  ***REMOVED*** else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
    const numericValue = parseFloat(value);
    if (!Number.isNaN(numericValue)) {
      value = parseFloat(value);
    ***REMOVED***
  ***REMOVED***

  return value;
***REMOVED***

// Options that are known boolean types
const BOOLEAN_OPTIONS = new Set([
  'slaveok',
  'slave_ok',
  'sslvalidate',
  'fsync',
  'safe',
  'retrywrites',
  'j'
]);

// Known string options, only used to bypass Number coercion in `parseQueryStringItemValue`
const STRING_OPTIONS = new Set(['authsource']);

// Supported text representations of auth mechanisms
// NOTE: this list exists in native already, if it is merged here we should deduplicate
const AUTH_MECHANISMS = new Set([
  'GSSAPI',
  'MONGODB-X509',
  'MONGODB-CR',
  'DEFAULT',
  'SCRAM-SHA-1',
  'SCRAM-SHA-256',
  'PLAIN'
]);

// Lookup table used to translate normalized (lower-cased) forms of connection string
// options to their expected camelCase version
const CASE_TRANSLATION = {
  replicaset: 'replicaSet',
  connecttimeoutms: 'connectTimeoutMS',
  sockettimeoutms: 'socketTimeoutMS',
  maxpoolsize: 'maxPoolSize',
  minpoolsize: 'minPoolSize',
  maxidletimems: 'maxIdleTimeMS',
  waitqueuemultiple: 'waitQueueMultiple',
  waitqueuetimeoutms: 'waitQueueTimeoutMS',
  wtimeoutms: 'wtimeoutMS',
  readconcern: 'readConcern',
  readconcernlevel: 'readConcernLevel',
  readpreference: 'readPreference',
  maxstalenessseconds: 'maxStalenessSeconds',
  readpreferencetags: 'readPreferenceTags',
  authsource: 'authSource',
  authmechanism: 'authMechanism',
  authmechanismproperties: 'authMechanismProperties',
  gssapiservicename: 'gssapiServiceName',
  localthresholdms: 'localThresholdMS',
  serverselectiontimeoutms: 'serverSelectionTimeoutMS',
  serverselectiontryonce: 'serverSelectionTryOnce',
  heartbeatfrequencyms: 'heartbeatFrequencyMS',
  appname: 'appName',
  retrywrites: 'retryWrites',
  uuidrepresentation: 'uuidRepresentation',
  zlibcompressionlevel: 'zlibCompressionLevel'
***REMOVED***;

/**
 * Sets the value for `key`, allowing for any required translation
 *
 * @param {object***REMOVED*** obj The object to set the key on
 * @param {string***REMOVED*** key The key to set the value for
 * @param {****REMOVED*** value The value to set
 * @param {object***REMOVED*** options The options used for option parsing
 */
function applyConnectionStringOption(obj, key, value, options) {
  // simple key translation
  if (key === 'journal') {
    key = 'j';
  ***REMOVED*** else if (key === 'wtimeoutms') {
    key = 'wtimeout';
  ***REMOVED***

  // more complicated translation
  if (BOOLEAN_OPTIONS.has(key)) {
    value = value === 'true' || value === true;
  ***REMOVED*** else if (key === 'appname') {
    value = decodeURIComponent(value);
  ***REMOVED*** else if (key === 'readconcernlevel') {
    key = 'readconcern';
    value = { level: value ***REMOVED***;
  ***REMOVED***

  // simple validation
  if (key === 'compressors') {
    value = Array.isArray(value) ? value : [value];

    if (!value.every(c => c === 'snappy' || c === 'zlib')) {
      throw new MongoParseError(
        'Value for `compressors` must be at least one of: `snappy`, `zlib`'
      );
    ***REMOVED***
  ***REMOVED***

  if (key === 'authmechanism' && !AUTH_MECHANISMS.has(value)) {
    throw new MongoParseError(
      'Value for `authMechanism` must be one of: `DEFAULT`, `GSSAPI`, `PLAIN`, `MONGODB-X509`, `SCRAM-SHA-1`, `SCRAM-SHA-256`'
    );
  ***REMOVED***

  if (key === 'readpreference' && !ReadPreference.isValid(value)) {
    throw new MongoParseError(
      'Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`'
    );
  ***REMOVED***

  if (key === 'zlibcompressionlevel' && (value < -1 || value > 9)) {
    throw new MongoParseError('zlibCompressionLevel must be an integer between -1 and 9');
  ***REMOVED***

  // special cases
  if (key === 'compressors' || key === 'zlibcompressionlevel') {
    obj.compression = obj.compression || {***REMOVED***;
    obj = obj.compression;
  ***REMOVED***

  if (key === 'authmechanismproperties') {
    if (typeof value.SERVICE_NAME === 'string') obj.gssapiServiceName = value.SERVICE_NAME;
    if (typeof value.SERVICE_REALM === 'string') obj.gssapiServiceRealm = value.SERVICE_REALM;
    if (typeof value.CANONICALIZE_HOST_NAME !== 'undefined') {
      obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
    ***REMOVED***
  ***REMOVED***

  // set the actual value
  if (options.caseTranslate && CASE_TRANSLATION[key]) {
    obj[CASE_TRANSLATION[key]] = value;
    return;
  ***REMOVED***

  obj[key] = value;
***REMOVED***

const USERNAME_REQUIRED_MECHANISMS = new Set([
  'GSSAPI',
  'MONGODB-CR',
  'PLAIN',
  'SCRAM-SHA-1',
  'SCRAM-SHA-256'
]);

/**
 * Modifies the parsed connection string object taking into account expectations we
 * have for authentication-related options.
 *
 * @param {object***REMOVED*** parsed The parsed connection string result
 * @return The parsed connection string result possibly modified for auth expectations
 */
function applyAuthExpectations(parsed) {
  if (parsed.options == null) {
    return;
  ***REMOVED***

  const options = parsed.options;
  const authSource = options.authsource || options.authSource;
  if (authSource != null) {
    parsed.auth = Object.assign({***REMOVED***, parsed.auth, { db: authSource ***REMOVED***);
  ***REMOVED***

  const authMechanism = options.authmechanism || options.authMechanism;
  if (authMechanism != null) {
    if (
      USERNAME_REQUIRED_MECHANISMS.has(authMechanism) &&
      (!parsed.auth || parsed.auth.username == null)
    ) {
      throw new MongoParseError(`Username required for mechanism \`${authMechanism***REMOVED***\``);
    ***REMOVED***

    if (authMechanism === 'GSSAPI') {
      if (authSource != null && authSource !== '$external') {
        throw new MongoParseError(
          `Invalid source \`${authSource***REMOVED***\` for mechanism \`${authMechanism***REMOVED***\` specified.`
        );
      ***REMOVED***

      parsed.auth = Object.assign({***REMOVED***, parsed.auth, { db: '$external' ***REMOVED***);
    ***REMOVED***

    if (authMechanism === 'MONGODB-X509') {
      if (parsed.auth && parsed.auth.password != null) {
        throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism***REMOVED***\``);
      ***REMOVED***

      if (authSource != null && authSource !== '$external') {
        throw new MongoParseError(
          `Invalid source \`${authSource***REMOVED***\` for mechanism \`${authMechanism***REMOVED***\` specified.`
        );
      ***REMOVED***

      parsed.auth = Object.assign({***REMOVED***, parsed.auth, { db: '$external' ***REMOVED***);
    ***REMOVED***

    if (authMechanism === 'PLAIN') {
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({***REMOVED***, parsed.auth, { db: '$external' ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // default to `admin` if nothing else was resolved
  if (parsed.auth && parsed.auth.db == null) {
    parsed.auth = Object.assign({***REMOVED***, parsed.auth, { db: 'admin' ***REMOVED***);
  ***REMOVED***

  return parsed;
***REMOVED***

/**
 * Parses a query string according the connection string spec.
 *
 * @param {String***REMOVED*** query The query string to parse
 * @param {object***REMOVED*** [options] The options used for options parsing
 * @return {Object|Error***REMOVED*** The parsed query string as an object, or an error if one was encountered
 */
function parseQueryString(query, options) {
  const result = {***REMOVED***;
  let parsedQueryString = qs.parse(query);

  for (const key in parsedQueryString) {
    const value = parsedQueryString[key];
    if (value === '' || value == null) {
      throw new MongoParseError('Incomplete key value pair for option');
    ***REMOVED***

    const normalizedKey = key.toLowerCase();
    const parsedValue = parseQueryStringItemValue(normalizedKey, value);
    applyConnectionStringOption(result, normalizedKey, parsedValue, options);
  ***REMOVED***

  // special cases for known deprecated options
  if (result.wtimeout && result.wtimeoutms) {
    delete result.wtimeout;
    console.warn('Unsupported option `wtimeout` specified');
  ***REMOVED***

  return Object.keys(result).length ? result : null;
***REMOVED***

const PROTOCOL_MONGODB = 'mongodb';
const PROTOCOL_MONGODB_SRV = 'mongodb+srv';
const SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];

/**
 * Parses a MongoDB connection string
 *
 * @param {****REMOVED*** uri the MongoDB connection string to parse
 * @param {object***REMOVED*** [options] Optional settings.
 * @param {boolean***REMOVED*** [options.caseTranslate] Whether the parser should translate options back into camelCase after normalization
 * @param {parseCallback***REMOVED*** callback
 */
function parseConnectionString(uri, options, callback) {
  if (typeof options === 'function') (callback = options), (options = {***REMOVED***);
  options = Object.assign({***REMOVED***, { caseTranslate: true ***REMOVED***, options);

  // Check for bad uris before we parse
  try {
    URL.parse(uri);
  ***REMOVED*** catch (e) {
    return callback(new MongoParseError('URI malformed, cannot be parsed'));
  ***REMOVED***

  const cap = uri.match(HOSTS_RX);
  if (!cap) {
    return callback(new MongoParseError('Invalid connection string'));
  ***REMOVED***

  const protocol = cap[1];
  if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
    return callback(new MongoParseError('Invalid protocol provided'));
  ***REMOVED***

  if (protocol === PROTOCOL_MONGODB_SRV) {
    return parseSrvConnectionString(uri, options, callback);
  ***REMOVED***

  const dbAndQuery = cap[4].split('?');
  const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
  const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;

  let parsedOptions;
  try {
    parsedOptions = parseQueryString(query, options);
  ***REMOVED*** catch (parseError) {
    return callback(parseError);
  ***REMOVED***

  parsedOptions = Object.assign({***REMOVED***, parsedOptions, options);
  const auth = { username: null, password: null, db: db && db !== '' ? qs.unescape(db) : null ***REMOVED***;
  if (cap[4].split('?')[0].indexOf('@') !== -1) {
    return callback(new MongoParseError('Unescaped slash in userinfo section'));
  ***REMOVED***

  const authorityParts = cap[3].split('@');
  if (authorityParts.length > 2) {
    return callback(new MongoParseError('Unescaped at-sign in authority section'));
  ***REMOVED***

  if (authorityParts.length > 1) {
    const authParts = authorityParts.shift().split(':');
    if (authParts.length > 2) {
      return callback(new MongoParseError('Unescaped colon in authority section'));
    ***REMOVED***

    auth.username = qs.unescape(authParts[0]);
    auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
  ***REMOVED***

  let hostParsingError = null;
  const hosts = authorityParts
    .shift()
    .split(',')
    .map(host => {
      let parsedHost = URL.parse(`mongodb://${host***REMOVED***`);
      if (parsedHost.path === '/:') {
        hostParsingError = new MongoParseError('Double colon in host identifier');
        return null;
      ***REMOVED***

      // heuristically determine if we're working with a domain socket
      if (host.match(/\.sock/)) {
        parsedHost.hostname = qs.unescape(host);
        parsedHost.port = null;
      ***REMOVED***

      if (Number.isNaN(parsedHost.port)) {
        hostParsingError = new MongoParseError('Invalid port (non-numeric string)');
        return;
      ***REMOVED***

      const result = {
        host: parsedHost.hostname,
        port: parsedHost.port ? parseInt(parsedHost.port) : 27017
      ***REMOVED***;

      if (result.port === 0) {
        hostParsingError = new MongoParseError('Invalid port (zero) with hostname');
        return;
      ***REMOVED***

      if (result.port > 65535) {
        hostParsingError = new MongoParseError('Invalid port (larger than 65535) with hostname');
        return;
      ***REMOVED***

      if (result.port < 0) {
        hostParsingError = new MongoParseError('Invalid port (negative number)');
        return;
      ***REMOVED***

      return result;
    ***REMOVED***)
    .filter(host => !!host);

  if (hostParsingError) {
    return callback(hostParsingError);
  ***REMOVED***

  if (hosts.length === 0 || hosts[0].host === '' || hosts[0].host === null) {
    return callback(new MongoParseError('No hostname or hostnames provided in connection string'));
  ***REMOVED***

  const result = {
    hosts: hosts,
    auth: auth.db || auth.username ? auth : null,
    options: Object.keys(parsedOptions).length ? parsedOptions : null
  ***REMOVED***;

  if (result.auth && result.auth.db) {
    result.defaultDatabase = result.auth.db;
  ***REMOVED***

  try {
    applyAuthExpectations(result);
  ***REMOVED*** catch (authError) {
    return callback(authError);
  ***REMOVED***

  callback(null, result);
***REMOVED***

module.exports = parseConnectionString;
